[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for Economic Research",
    "section": "",
    "text": "Over the past years I’ve received a lot of messages asking what I considered to be the most important subjects one should learn in order to start a career in economic research. R for Economic Research is my contribution to those who have some knowledge of R programming but still lack the necessary tools to carry out professional economic analysis. This is an intermediate-level book where the reader will find shortcuts to start working on a variety of tasks and also valuable references to delve into the details of more complex topics.\nAfter six years as a professional in this field, I believe I am in a position to suggest a set of necessary tools for this type of work. The reasoning behind the book can be described as follows.\nModern economic research requires a solid knowledge of a programming language. In fact, with a growing set of data now available through APIs it is possible to produce automated analyzes almost instantly using efficient techniques. In addition, unstructured data only becomes true information if correctly handled. I chose R because I strongly believe that Tidyverse is unrivaled as a data science workflow.\nIt does require more than just programming. Indeed, I have interviewed several applicants who were quite proficient in programming but lacked knowledge of basic topics on applied time series. For example, they didn’t know how to perform seasonal adjustment nor how to deflating nominal to real values. Filling in these gaps is crucial.\nKnowledge about forecasting is vital. I’m definitely not talking about state-of-the-art machine learning models. In fact, most problems can be addressed with traditional statistical methods. Setting up the workflow to generate reliable forecasts is the relevant skill here.\nTaking it to the next level. Some tools allow us to considerably expand our possibilities. Learning how to build and estimate state-space models is undoubtedly a big step forward in becoming a senior analyst.\nI can’t help but talk about economic modelling. Estimating the relationship between economic variables and making projections is the core business of those who work with economic research. Despite being a topic that requires theoretical and applied training beyond the scope of this book, I believe that showing how to set up the framework for these models is a valuable contribution for those who want to start in the field."
  },
  {
    "objectID": "ds_tidyverse.html",
    "href": "ds_tidyverse.html",
    "title": "1  Introduction",
    "section": "",
    "text": "The purpose of this chapter is to introduce the main functions of the core packages in tidyverse. It’s not intended to be a thorough description of every function, rather the idea is to provide the basic tools so that those who are either base R users or aren’t R users at all can follow along with the rest of the book. For a more detailed approach to tidyverse, the best source is undoubtedly the great Grolemund and Wickham (2017). For those who feel comfortable with tidyverse, a quick skim through the chapter might be enough."
  },
  {
    "objectID": "ds_tidyverse.html#whats-tidyverse",
    "href": "ds_tidyverse.html#whats-tidyverse",
    "title": "1  Introduction",
    "section": "1.1 What’s tidyverse?",
    "text": "1.1 What’s tidyverse?\nTo start, what’s tidyverse? According to the official website:\n\nThe tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.\n\nFrom my own experience I can ensure you that tidyverse is all you need to carry out data analyses as neat, flexible and readable as possible. By neat I mean succinct code without any redundancy, i.e, a single block of code (not a bunch of loose objects) doing all the desired task. Flexible, in turn, means the code is general enough. It depends on the nature of the task at hand, so take it more like a philosophy. For example, does the solution still work if the data is updated with new values? Does it depend on changeable references such as column positions? Finally, readable means that not only the understanding of the code is straightforward.\nMost of the time writing neat, flexible and readable code takes longer and requires a dose of creativity, but it surely pays off. Moreover, with practice this will become more and more natural and the cost will get significantly lower. In the next sections we’ll review the most used functions to go through all the steps of everyday data analyses using core tidyverse packages designed to Import, Wrangle, Program and Plot."
  },
  {
    "objectID": "ds_tidyverse.html#import",
    "href": "ds_tidyverse.html#import",
    "title": "1  Introduction",
    "section": "1.2 Importing",
    "text": "1.2 Importing\n\n1.2.1 Reading from flat files\nreadr is the tidyverse’s package used to import data from flat files (basically .csv and .txt files). The most generic function is read_delim as it has a large set of parameters that allow us to declare the structure of the data we want to import. In practice, we often use the read_csv which is a special case of the former with some predefined settings suitable for .csv files – the most obvious being the comma as the column delimiter.\nIf you’re running RStudio IDE, I recommend you to click on Import Dataset at the Environment sheet (by default it’s located on the upper right panel) to manually define the appropriate settings for your file. We should never be encouraged to use windows, click on buttons or any kind of shortcuts provided by the IDE. This is the only exception I think is worth it. First, because it can be tedious to set many specific parameters via trial-and-error to correctly import your data. Second, because once you have the configuration done the code is displayed at the bottom of the window so you can copy it and paste it on your script and, eventually, get rid of this shortcut as you learn how things work. Lastly, you probably won’t repeat this action many times when working on a given task and there’s not much to improve on this process. Then, Yes, it’s a big waste of time trying to understand each single parameter.\nJust for the sake of illustration, let’s use readr to import the COVID data set from Our World in Data. It’s a standard .csv file, so we can use read_csv without any additional parameter. We just need to provide the file path:\n\nlibrary(tidyverse)\ndata_path <- 'data/owid-covid-data.csv'\ncovid_data <- read_csv(data_path)\n\nor the URL:\n\ndata_url <- 'https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv'\ncovid_data <- read_csv(data_url)\n\nTidyverse also provides packages for reading other usual file types. For instance, we can use readxl to read MS Excel spreadsheets and haven to read data generated by popular statistical softwares (SPSS, Stata and SAS) in much the same way we did with readr for .csv files (you can check them at the Import Dataset dropdown menu) so we won’t cover them. Rather, let’s use the rest of this section to talk about something very important and that usually gets less attention in books: reading data from an API.\n\n\n1.2.2 Reading from API\nAlthough the use of traditional flat files are still widespread, organizations are increasingly switching to API’s to make data available to the public. This is a huge improvement since we’re able to customize our demand and retrieve only the data we need for the specific task.\nIf you don’t know what an API is, think of it as an interface to a database. However, instead of reading all the content from this database you can inform what columns you want, the desired observations (time range if it’s a time series) and so on. These filters are embedded in a request and the right form to specify it is usually available in a documentation provided by the API maintainer.\nFor example, the Federal Reserve Bank of St. Louis maintains a huge repository with hundreds of thousands of economic time series and we can import them using an API. The information on how to build the request is available in the documentation, where we can see a link with instructions on how to ‘Get the observations or data values for an economic data series’. There, we find an example of a request for the US Real Gross National Product:\nhttps://api.stlouisfed.org/fred/series/observations?series_id=GNPCA&api_key=abcdefghijklmnopqrstuvwxyz123456&file_type=json\nWe can break this request down to see its parts in more detail:\n\nThe main (static) URL to access the Observations section in the API.\n\n\\[\n\\underbrace{\\text{https://api.stlouisfed.org/fred/series/observations?}}_\\text{Static: API URL}\n\\] 2. The series ID which identifies the data for the US Real Gross National Product.\n\\[\n\\underbrace{\\text{series\\_id=GNPCA}}_\\text{Parameter: Series ID}\n\\]\n\nThe API Key. We must create an account and require a personal key in order to retrieve data from the API. This one is an example for illustrative purposes only.\n\n\\[\n\\underbrace{\\text{api\\_key=abcdefghijklmnopqrstuvwxyz123456}}_\\text{Parameter: API Key}\n\\]\n\nThe file type for the output. There are several types, but I’d rather working with JSON.\n\n\\[\n\\underbrace{\\text{file\\_type=json}}_\\text{Parameter: File Type}\n\\]\nNote that all the parameters following the static part is separated by an &. Then, if we want to add any extra parameter it should be placed right after this symbol. Also, the order of the parameters is not relevant.\nSuppose we want to read monthly data for the US Consumer Price Index (CPI). The series_id is CPALTT01USM657N. Besides, we’d only like to read data between January 2010 and December 2022. How can we do so? There are two parameters – observation_start and observation_end which set, respectectively, the start and end of the observation period (YYYY-MM-DD format).\nThe code below creates a separate object for each part of the request. Then, we use the glue function from the homonymous package to merge the pieces into a single string adding the & symbol between parameters. We could create the full string all at once, but creating separate objects makes it easier to find and edit values as well as to transform this task into a function if we had to frequently read data from this source (more on this later).\nYou’ll need to register in order to receive access to the API. Since this information is personal, I stored my key as an environmental variable named api_fred_key.\n\nlibrary(glue)\napi_url       <- 'https://api.stlouisfed.org/fred/series/observations?'\napi_fred_key  <- Sys.getenv('api_fred_key')\napi_series_id <- 'CPALTT01USM657N'\nobs_start     <- '2010-01-01'\nobs_end       <- '2022-12-01'\napi_filetype  <- 'json'\napi_request   <- glue('{api_url}series_id={api_series_id}&observation_start={obs_start}&observation_end={obs_end}&api_key={api_fred_key}&file_type={api_filetype}')\n\nNow we use the httr package to connect to the API, send the request and get the content. The other steps transform the content from JSON to a standard R object (a list) and then convert it to a tibble (the tidyverse’s improved format for data frames). Notice that the CPI data is stored in the list element named observations. However, this is specific for this API and if we were to import data from another source we’d have to check in which element the data would be stored.\n\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(tidyverse)\ncpi_request <- GET(url = api_request)\ncpi_content <- content(cpi_request, as = 'text')\ncpi_list    <- fromJSON(cpi_content, flatten = FALSE)\ncpi_tbl     <- cpi_list[['observations']] %>% as_tibble()\ncpi_tbl\n\n# A tibble: 156 x 4\n   realtime_start realtime_end date       value              \n   <chr>          <chr>        <chr>      <chr>              \n 1 2023-04-04     2023-04-04   2010-01-01 0.34174735701485   \n 2 2023-04-04     2023-04-04   2010-02-01 0.024920738207648  \n 3 2023-04-04     2023-04-04   2010-03-01 0.410628353657108  \n 4 2023-04-04     2023-04-04   2010-04-01 0.173688491069743  \n 5 2023-04-04     2023-04-04   2010-05-01 0.0775197354237721 \n 6 2023-04-04     2023-04-04   2010-06-01 -0.0976267084673888\n 7 2023-04-04     2023-04-04   2010-07-01 0.0211043057371509 \n 8 2023-04-04     2023-04-04   2010-08-01 0.138066427840807  \n 9 2023-04-04     2023-04-04   2010-09-01 0.0581736230715569 \n10 2023-04-04     2023-04-04   2010-10-01 0.124519888847696  \n# ... with 146 more rows\n\n\nThis concludes our section on how to import data. If you’re struggling with other types of data, Tidyverse’s official website provides a comprehensive list of all the supported file formats and the respective packages used to handle them."
  },
  {
    "objectID": "ds_tidyverse.html#wrangling",
    "href": "ds_tidyverse.html#wrangling",
    "title": "1  Introduction",
    "section": "1.3 Wrangling",
    "text": "1.3 Wrangling\nThis is by far the most important section in this Chapter. The main goal here is to provide a general sense of how to get raw data ready to use. For this, we’ll focus on the roles of the main functions from dplyr package rather than the idiosyncrasies and generalizations of each one. More complex applications will be shown in the next chapters.\n\n1.3.1 Data manipulation\nLet’s use the COVID data we imported in the last section. Starting with the glimpse function to have a grasp of the data, we can see some useful information such as the number of rows and columns, as well as columns’ names and classes (whether they’re character, double, etc).\n\ncovid_data %>% \n  glimpse()\n\nWe’re usually not interested in all of these data, so the first couple of tasks we’d like to perform is to filter the relevant categories and select the desired columns. For example, we could be interested in analyzing new COVID cases (column new_cases) only in Brazil (rows equal to Brazil in column location). Furthermore, we’d like to get rid of duplicate rows if there’s any.\nOne of the great contributions of tidyverse is to assign names (verbs) to the functions according to the actions they perform – many are admittedly SQL-inspired. For example, distinct drops observations (rows) which are not unique, whereas select picks variables based on their names (or positions). The exception is filter, which retains the rows which satisfy a given condition (the analogue of WHERE in SQL).\nConditions are sentences which returns TRUE or FALSE. It’s straightforward to think of conditions using logical operators, such as ==, >, <, etc. Nevertheless, there’s a bunch of expressions in R which return TRUE or FALSE. Moreover, we can always create our own condition to generate the desired output. We’ll see many examples throughout this book.\nThe code below performs the initial steps described above to generate a subset of the data.\n\ncovid_data_sub1 <- covid_data %>% \n  distinct() %>% \n  select(date, continent, location, new_cases) %>% \n  filter(location == 'Brazil')\n\nNext, we’d probably need to create additional columns. For instance, suppose that actual new cases in Brazil are much higher than reported because the country doesn’t have enough tests and a conservative estimate points to a number of, say, twice the official count. So we’d like to add a column which is twice the value of the original one representing our guess of the real situation. In addition, we’d also like to create a column to indicate the dominant strain at each period of time. We know that the Delta strain took over Gamma by the end of July 2021 and, then, Omicron took over Delta in the beginning of 2022.\nThe mutate verb can be used to create new variables as a function of existing ones. Also, it can be used to modify existing variables as new variables overwrites those with the same name. case_when is another SQL-inspired function used inside mutate to create a new variable based on conditions. It’s worth noting that it returns NA if no condition is met. In this case, a useful workaround is to define an extra condition as TRUE ~ value, thus assigning a value to all the unmet conditions – think of this as an else condition.\n\ncovid_data_sub2 <- covid_data_sub1 %>% \n  mutate(\n    real_new_cases = 2*new_cases,\n    dominant_strain  = case_when(\n      date <= '2021-07-31'                        ~ 'Gamma',\n      date >  '2021-07-31' & date <= '2021-12-31' ~ 'Delta',\n      date >  '2021-12-31' & date <= '2022-02-01' ~ 'Omicron',\n      TRUE                                        ~ \"We don't know\"\n    )\n  )\n\nThe between function is a shortcut for numeric conditions that are bounded both on the left and on the right. It also works with dates if we declare the arguments as date objects. Therefore, we can replace conditions 2 and 3 to have a more compact and efficient code (it’s implemented in C++, like many modern R functions).\n\ncovid_data_sub2 <- covid_data_sub1 %>% \n  mutate(\n    real_new_cases = 2*new_cases,\n    dominant_strain  = case_when(\n      date <= '2021-07-31'                                          ~ 'Gamma',\n      between(date, as.Date('2021-07-31'), as.Date('2021-12-31'))   ~ 'Delta',\n      between(date, as.Date('2021-12-31'), as.Date('2022-02-01'))   ~ 'Omicron',\n      TRUE                                                          ~ \"We don't know\"\n    )\n  )\n\nSo far we’ve worked on a single group of data: new cases in Brazil. However, we usually have many categories to work on. We might be interested in analyzing new cases in all European countries, for example. In this case, we’ll need the group_by function, which allows us to perform operations by group. group_by is often used in conjunction with mutate or summarise to create new data for each group. The latter uses aggregate functions (mean, max, min, etc) to produce a summary of the data.\nFor example, suppose we want to know which European country recorded the highest number of new covid cases in a single day by the mid of 2022. This might be achieved by grouping the data by location and then using summarise with max. In addition, we can use arrange to sort the rows by value (we use desc to sort in descending order). Don’t forget to ungroup data as soon as you no longer need to perform operations by group.\n\ncovid_data_sub3 <- covid_data %>% \n  distinct() %>% \n  filter(\n    continent == 'Europe',\n    date <= '2021-06-30'\n    ) %>% \n  group_by(location) %>% \n  summarise(max_new_cases = max(new_cases)) %>% \n  ungroup() %>% \n  arrange(desc(max_new_cases))\ncovid_data_sub3\n\n# A tibble: 51 x 2\n   location       max_new_cases\n   <chr>                  <dbl>\n 1 United Kingdom         68066\n 2 Germany                45333\n 3 Italy                  40902\n 4 Poland                 35253\n 5 Sweden                 32485\n 6 Russia                 29499\n 7 Belgium                23921\n 8 Switzerland            21926\n 9 Ukraine                20456\n10 Netherlands            13037\n# ... with 41 more rows\n\n\nNote that some countries such as Spain, Portugal and France returned NA. This happened because they probably have any missing value. We could easily ignore it by passing the argument na.rm = TRUE to the max function. However, another problem would arise: countries with no data on new cases would return -Inf. To get around these two issues, we can filter all the missing values out in the data set using the logical operator is.na() (the ! before the condition works as a negation). In this case removing the missing values isn’t a problem, but be aware that for some tasks this may influence the outcome.\n\ncovid_data_sub4 <- covid_data %>% \n  distinct() %>% \n  filter(\n    continent == 'Europe',\n    date <= '2022-06-30',\n    !is.na(new_cases)\n    ) %>% \n  group_by(location) %>% \n  summarise(max_new_cases = max(new_cases)) %>% \n  ungroup() %>% \n  arrange(desc(max_new_cases))\ncovid_data_sub4\n\n# A tibble: 49 x 2\n   location       max_new_cases\n   <chr>                  <dbl>\n 1 France                117900\n 2 Germany               103018\n 3 Spain                  93822\n 4 United Kingdom         92713\n 5 Belgium                47836\n 6 Italy                  40902\n 7 Russia                 40210\n 8 Poland                 35253\n 9 Sweden                 32485\n10 Ukraine                28477\n# ... with 39 more rows\n\n\nIn addition, we might want to know not only what the highest numbers were but when they did occur (the peak date). Since the summarise function is designed to return a single value, we must use an expression which returns a single value. If we used date = max(date), we’d keep the most recent date for the data in each country. Definitely, that’s not what we want. So a good way to address this issue is to combine a subset operation with a condition inside. In simpler terms, we’ll subset from the column date the observation where new cases were at its high. Since we can have multiple dates which satisfy this condition, we’ll keep the most recent one (the max of them).\n\ncovid_data_sub5 <- covid_data %>% \n  distinct() %>% \n  filter(\n    continent == 'Europe',\n    date <= '2022-06-30',\n    !is.na(new_cases)\n    ) %>% \n  group_by(location) %>% \n  summarise(\n    max_new_cases = max(new_cases),\n    peak_date = date[which(new_cases == max_new_cases)] %>% max()\n    ) %>% \n  ungroup() %>% \n  arrange(desc(max_new_cases), peak_date) %>% \n  slice(1:10)\ncovid_data_sub5\n\n# A tibble: 10 x 3\n   location       max_new_cases peak_date \n   <chr>                  <dbl> <date>    \n 1 France                117900 2021-04-11\n 2 Germany               103018 2021-12-09\n 3 Spain                  93822 2021-01-25\n 4 United Kingdom         92713 2021-12-17\n 5 Belgium                47836 2021-11-29\n 6 Italy                  40902 2020-11-13\n 7 Russia                 40210 2021-11-06\n 8 Poland                 35253 2021-04-01\n 9 Sweden                 32485 2020-12-29\n10 Ukraine                28477 2021-11-04\n\n\nIn case it went unnoticed, the previous code showed a really nice feature of mutate/summarise: you can use a variable you’ve just created in a subsequent task inside the same calling. In this example, we used the maximum number of new cases (first variable) as a reference to obtain the dates when it occurred (second variable), all of this inside the same summarise calling as if all steps were performed sequentially.\nIn the last two lines, we used arrange to sort countries firstly by the maximum number of new cases and then by their peak date and slice to subset only the first ten countries out of the forty-nine in our data set. This ends our approach to single data sets for now.\nBut before we jump to the next section, there’s something very important to address: merging multiple data sets. There are two families of functions in dplyr to merge data frames, *_join and bind_*. Let’s see how they work.\nThe *_join functions are used to merge two data frames horizontally, matching their rows based on specified keys. For example, take the covid_data_sub5 data frame we created above. It contains the top ten European countries with the highest number of new Covid cases in a single day and their peak dates. Suppose we want to add information on the population size for each country, which is available in another data frame named europe_population displayed below.1\n\n\n# A tibble: 51 x 2\n   Country         Pop_size\n   <chr>              <dbl>\n 1 Russia         145912022\n 2 Germany         83900471\n 3 United Kingdom  68207114\n 4 France          67564251\n 5 Italy           60367471\n 6 Spain           46745211\n 7 Ukraine         43466822\n 8 Poland          37797000\n 9 Romania         19127772\n10 Netherlands     17173094\n# ... with 41 more rows\n\n\nWhat we want here is to add the column Pop_Size from europe_population into covid_data_sub5 matching rows based on location (the column with countries in the main data set). For this, we can use the left_join function, which adds the content from the second data frame to the first one. The by argument is needed because the name of the key column differs across the data sets.2\n\ncovid_data_sub5_with_pop <- covid_data_sub5 %>% \n  left_join(europe_population, by = c('location' = 'Country'))\ncovid_data_sub5_with_pop\n\n# A tibble: 10 x 4\n   location       max_new_cases peak_date   Pop_size\n   <chr>                  <dbl> <date>         <dbl>\n 1 France                117900 2021-04-11  67564251\n 2 Germany               103018 2021-12-09  83900471\n 3 Spain                  93822 2021-01-25  46745211\n 4 United Kingdom         92713 2021-12-17  68207114\n 5 Belgium                47836 2021-11-29  11632334\n 6 Italy                  40902 2020-11-13  60367471\n 7 Russia                 40210 2021-11-06 145912022\n 8 Poland                 35253 2021-04-01  37797000\n 9 Sweden                 32485 2020-12-29  10160159\n10 Ukraine                28477 2021-11-04  43466822\n\n\nWe could have been assigned a slightly different task. For example, adding to european_population the information on maximum daily number of new Covid cases and peak dates we have from covid_data_sub5. This can also be achieved with left_join by reversing the order of the data frames (and names of the key column since they’re not the same). An effortless alternative is to replace left_join with right_join, which adds to the second data frame (the one on the right) the information from the first data frame (the one on the left). In this case we don’t need to change the order of the parameters.\n\npop_with_covid_info <- covid_data_sub5 %>% \n  right_join(europe_population, by = c('location' = 'Country'))\npop_with_covid_info\n\n# A tibble: 51 x 4\n   location       max_new_cases peak_date   Pop_size\n   <chr>                  <dbl> <date>         <dbl>\n 1 France                117900 2021-04-11  67564251\n 2 Germany               103018 2021-12-09  83900471\n 3 Spain                  93822 2021-01-25  46745211\n 4 United Kingdom         92713 2021-12-17  68207114\n 5 Belgium                47836 2021-11-29  11632334\n 6 Italy                  40902 2020-11-13  60367471\n 7 Russia                 40210 2021-11-06 145912022\n 8 Poland                 35253 2021-04-01  37797000\n 9 Sweden                 32485 2020-12-29  10160159\n10 Ukraine                28477 2021-11-04  43466822\n# ... with 41 more rows\n\n\nAt first glance it seems to produce the same outcome, but notice that the number of rows are different in the two resulting data sets. In the first case left_join kept all the rows from covid_data_sub5 and only the corresponding rows from europe_population, whereas right_join did the opposite. In summary, left_join and right_join keep all the rows from just one of the two data frames.\nSometimes, however, we want to keep all the rows from both data frames. For example, imagine that covid_data_sub5 had data not only on European but on South American countries as well. In addition, the european_population data frame also included the populations from Asian countries. If we merged the data frames using the functions above, we’d end up loosing observations on either Covid in South America or populations in Asia.\nIn order to merge the data frames by their common countries while keeping the remaining observations from both, we should employ the full_join function. On the other hand, if we’re willing to keep only the common countries in both data frames, this is the case for the inner_join function.\nThese four functions comprise what it’s called mutating-joins since they add columns from one data frame to the other. There are also the filtering-joins functions, which filter the rows from one data frame based on the presence (semi_join) or absence (anti_join) of matches in the other data frame. Given the latter category is used to a much lesser extent, I won’t go into detail right now. Eventually they’ll show up in the coming chapters.\nWe saw that *_join* operations are particularly useful to merge data frames horizontally and by their matching rows according to key variables. More often than not we need to stack data vertically by their matching columns. For example, suppose the Covid data set was released as a single file for each country and we needed to perform some comparisons between France and the United Kingdom - covid_fr and covid_uk data sets shown below.\n\n\n# A tibble: 690 x 3\n   date       location       new_cases\n   <date>     <chr>              <dbl>\n 1 2020-01-31 United Kingdom         2\n 2 2020-02-01 United Kingdom         0\n 3 2020-02-02 United Kingdom         0\n 4 2020-02-03 United Kingdom         6\n 5 2020-02-04 United Kingdom         0\n 6 2020-02-05 United Kingdom         1\n 7 2020-02-06 United Kingdom         0\n 8 2020-02-07 United Kingdom         0\n 9 2020-02-08 United Kingdom         4\n10 2020-02-09 United Kingdom         1\n# ... with 680 more rows\n\n\n# A tibble: 697 x 4\n   date       location new_cases total_cases\n   <date>     <chr>        <dbl>       <dbl>\n 1 2020-01-24 France           2           2\n 2 2020-01-25 France           1           3\n 3 2020-01-26 France           0           3\n 4 2020-01-27 France           0           3\n 5 2020-01-28 France           1           4\n 6 2020-01-29 France           1           5\n 7 2020-01-30 France           0           5\n 8 2020-01-31 France           0           5\n 9 2020-02-01 France           1           6\n10 2020-02-02 France           0           6\n# ... with 687 more rows\n\n\nThis can be easily accomplished by bind_rows which, unlike the *_join family, allows us to provide several data frames. What’s cool about bind_rows is that non-matching columns are kept with their values filled with NA for the data frames where the column is absent. In the example above, the covid_fr data set has a total cases column which is absent in covid_uk.\n\n\n# A tibble: 1,387 x 4\n   date       location new_cases total_cases\n   <date>     <chr>        <dbl>       <dbl>\n 1 2020-01-24 France           2           2\n 2 2020-01-25 France           1           3\n 3 2020-01-26 France           0           3\n 4 2020-01-27 France           0           3\n 5 2020-01-28 France           1           4\n 6 2020-01-29 France           1           5\n 7 2020-01-30 France           0           5\n 8 2020-01-31 France           0           5\n 9 2020-02-01 France           1           6\n10 2020-02-02 France           0           6\n# ... with 1,377 more rows\n\n\nThe bind_cols function is more restrictive in this regard. It’s used to merge the columns of data frames, but matching by row position rather than a key variable. For this reason, we can’t have data frames of different lengths. In practice, it’s much more common to rely on *_join* functions when we need to merge data frames horizontally.\n\n\n1.3.2 Data layout\nWe’ve walked through the main functions of dplyr. Now, we turn to the tidyr package. According to tidyverse’s website, the goal of tidyr is to help us create tidy data. It means a data set where every column is a variable; every row is an observation; and each cell is a single value. This is more like a convention created by tidyverse so that “you’ll spend less time fighting with the tools and more time working on your analysis”.\nTidy data is also known as wide format – since it increases the number of columns and decreases the number of rows –, as opposed to the long format, where data are stacked increasing the number of rows and decreasing the number of columns. It took me a while before I could tell if a data set was either in wide or long format, so don’t worry if it’s not so clear right now. Perhaps a more direct way of thinking about this distinction is to ask yourself: Is all the information contained in a single cell?. If so, it’s wide format. If not, then it’s long format.\nFor example, is the Covid data set in wide or long format? If we took a single cell from the new_cases column, does it convey all the information for this variable? No, it doesn’t. We know the number of new cases in a given date, but we don’t know the country that value refers to – is this from Germany? Nigeria? Chile?\nWe can use the pivot_wider function from tidyr package to convert from long to wide format. The syntax is very easy to understand: names_from is the column we want to widen, whereas values_from is the column containing the observations that will fill each cell. id_cols is a parameter used to declare the set of columns that uniquely identifies each observation. In practice, it drops all the other columns in the data set. Hence, if we want to keep all the other variables, just skip it.\n\ncovid_wide_01 <- covid_data %>% \n  pivot_wider(\n    id_cols     = 'date', \n    names_from  = 'location', \n    values_from = 'new_cases'\n  )\ncovid_wide_01\n\n# A tibble: 720 x 226\n   date       Afghanistan Albania Algeria Andorra Angola Anguilla\n   <date>           <dbl>   <dbl>   <dbl>   <dbl>  <dbl>    <dbl>\n 1 2020-02-24           5      NA      NA      NA     NA       NA\n 2 2020-02-25           0      NA       1      NA     NA       NA\n 3 2020-02-26           0      NA       0      NA     NA       NA\n 4 2020-02-27           0      NA       0      NA     NA       NA\n 5 2020-02-28           0      NA       0      NA     NA       NA\n 6 2020-02-29           0      NA       0      NA     NA       NA\n 7 2020-03-01           0      NA       0      NA     NA       NA\n 8 2020-03-02           0      NA       2       1     NA       NA\n 9 2020-03-03           0      NA       2       0     NA       NA\n10 2020-03-04           0      NA       7       0     NA       NA\n# ... with 710 more rows, and 219 more variables: `Antigua and Barbuda` <dbl>,\n#   Argentina <dbl>, Armenia <dbl>, Aruba <dbl>, Australia <dbl>,\n#   Austria <dbl>, Azerbaijan <dbl>, Bahamas <dbl>, Bahrain <dbl>,\n#   Bangladesh <dbl>, Barbados <dbl>, Belarus <dbl>, Belgium <dbl>,\n#   Belize <dbl>, Benin <dbl>, Bermuda <dbl>, Bhutan <dbl>, Bolivia <dbl>,\n#   `Bonaire Sint Eustatius and Saba` <dbl>, `Bosnia and Herzegovina` <dbl>,\n#   Botswana <dbl>, Brazil <dbl>, `British Virgin Islands` <dbl>, ...\n\n\nNotice that now we have 225 columns rather than 67 of the original data set with each cell conveying the whole information: new cases in a given date for a specific country. So, what if we wanted to have both new_cases and new_deaths columns in wide form? We just need to provide a vector with the desired variables in values_from. By default, the new columns will be named according to the following pattern: variable_location.\nSince the variables names already contain a single underscore, it’s a good idea to set a different character as separator – a double underscore works fine. This is because we might need to reverse the operation later for a given task, then it’s much easier to identify it. Otherwise, we’d have to use regular expression to inform the specific position of the repeated character – for example, whether it’s the first or the second underscore.\n\ncovid_wide_02 <- covid_data %>% \n  pivot_wider(\n    id_cols     = 'date', \n    names_from  = 'location', \n    values_from = c('new_cases', 'new_deaths'),\n    names_sep   = '__'\n  )\ncovid_wide_02\n\n# A tibble: 720 x 451\n   date       new_cases__Afghanistan new_cases__Albania new_cases__Algeria\n   <date>                      <dbl>              <dbl>              <dbl>\n 1 2020-02-24                      5                 NA                 NA\n 2 2020-02-25                      0                 NA                  1\n 3 2020-02-26                      0                 NA                  0\n 4 2020-02-27                      0                 NA                  0\n 5 2020-02-28                      0                 NA                  0\n 6 2020-02-29                      0                 NA                  0\n 7 2020-03-01                      0                 NA                  0\n 8 2020-03-02                      0                 NA                  2\n 9 2020-03-03                      0                 NA                  2\n10 2020-03-04                      0                 NA                  7\n# ... with 710 more rows, and 447 more variables: new_cases__Andorra <dbl>,\n#   new_cases__Angola <dbl>, new_cases__Anguilla <dbl>,\n#   `new_cases__Antigua and Barbuda` <dbl>, new_cases__Argentina <dbl>,\n#   new_cases__Armenia <dbl>, new_cases__Aruba <dbl>,\n#   new_cases__Australia <dbl>, new_cases__Austria <dbl>,\n#   new_cases__Azerbaijan <dbl>, new_cases__Bahamas <dbl>,\n#   new_cases__Bahrain <dbl>, new_cases__Bangladesh <dbl>, ...\n\n\nOur new data set expanded to 450 columns. As we create more and more columns to get a wide data set it might become harder to perform some simple tasks. For example, using filter is generally easier than using a conditional select when we want to keep only the relevant data.\nIn summary, long format may be preferable over wide format when the data set contains more than one grouping variable or we want to work on more than one variable. Besides, long format data sets are ideal for plotting with ggplot2 package as we’ll see later.\nTherefore, it’s not unusual to convert a data set from wide to long format. The syntax is very similar to what we saw earlier when converting from long to wide format. The unique difference is in cols argument, used to declare what columns we want to stack. However, since wide data sets usually have a large number of columns and we’re often interested in putting all of them in long format, it’s much easier to declare what columns we want to leave out (-).\n\ncovid_long_01 <- covid_wide_02 %>% \n  pivot_longer(\n    cols      = -'date',\n    names_to  = c('variable', 'location'),\n    values_to = 'value',\n    names_sep = '__'\n  )\ncovid_long_01\n\n# A tibble: 324,000 x 4\n   date       variable  location            value\n   <date>     <chr>     <chr>               <dbl>\n 1 2020-02-24 new_cases Afghanistan             5\n 2 2020-02-24 new_cases Albania                NA\n 3 2020-02-24 new_cases Algeria                NA\n 4 2020-02-24 new_cases Andorra                NA\n 5 2020-02-24 new_cases Angola                 NA\n 6 2020-02-24 new_cases Anguilla               NA\n 7 2020-02-24 new_cases Antigua and Barbuda    NA\n 8 2020-02-24 new_cases Argentina              NA\n 9 2020-02-24 new_cases Armenia                NA\n10 2020-02-24 new_cases Aruba                  NA\n# ... with 323,990 more rows\n\n\nNote that now even the variables (new_cases and new_deaths) are stored in a single column (variable). This is probably an abuse of language, but I call this a complete long format – as opposed to the original format where the data set was only partially in the long format (the variables were indeed in wide format). For most applications, I think this is the best way to organize the data.\nConverting a data set between wide and long formats might not completely solve our problem. Sometimes, two pieces of information are merged in a single column. For example, suppose that the location column had both the continent and country names instead of only the country as in the original data set. We’ll call this data set covid_loc_cont.\n\n\n# A tibble: 139,819 x 4\n   location         date       new_cases new_deaths\n   <chr>            <date>         <dbl>      <dbl>\n 1 Afghanistan_Asia 2020-02-24         5         NA\n 2 Afghanistan_Asia 2020-02-25         0         NA\n 3 Afghanistan_Asia 2020-02-26         0         NA\n 4 Afghanistan_Asia 2020-02-27         0         NA\n 5 Afghanistan_Asia 2020-02-28         0         NA\n 6 Afghanistan_Asia 2020-02-29         0         NA\n 7 Afghanistan_Asia 2020-03-01         0         NA\n 8 Afghanistan_Asia 2020-03-02         0         NA\n 9 Afghanistan_Asia 2020-03-03         0         NA\n10 Afghanistan_Asia 2020-03-04         0         NA\n# ... with 139,809 more rows\n\n\nThis is undesirable since we can no longer use group_by or filter over continents alone, for instance. Hence, the best practice is to have a single column for each variable. This can be easily achieved using the separate function, with a highly self-explanatory syntax. Again, the separator character being unique in the string makes the job much easier.\n\ncovid_separate <- covid_loc_cont %>% \n  separate(\n    col  = 'location',\n    into = c('location', 'continent'),\n    sep  = '_'\n  )\ncovid_separate\n\n# A tibble: 139,819 x 5\n   location    continent date       new_cases new_deaths\n   <chr>       <chr>     <date>         <dbl>      <dbl>\n 1 Afghanistan Asia      2020-02-24         5         NA\n 2 Afghanistan Asia      2020-02-25         0         NA\n 3 Afghanistan Asia      2020-02-26         0         NA\n 4 Afghanistan Asia      2020-02-27         0         NA\n 5 Afghanistan Asia      2020-02-28         0         NA\n 6 Afghanistan Asia      2020-02-29         0         NA\n 7 Afghanistan Asia      2020-03-01         0         NA\n 8 Afghanistan Asia      2020-03-02         0         NA\n 9 Afghanistan Asia      2020-03-03         0         NA\n10 Afghanistan Asia      2020-03-04         0         NA\n# ... with 139,809 more rows\n\n\nThe only caveat to all this simplicity is when we have non-trivial separators. For example, imagine that we had no underscore to separate location from continent.\n\n\n# A tibble: 139,819 x 4\n   location        date       new_cases new_deaths\n   <chr>           <date>         <dbl>      <dbl>\n 1 AfghanistanAsia 2020-02-24         5         NA\n 2 AfghanistanAsia 2020-02-25         0         NA\n 3 AfghanistanAsia 2020-02-26         0         NA\n 4 AfghanistanAsia 2020-02-27         0         NA\n 5 AfghanistanAsia 2020-02-28         0         NA\n 6 AfghanistanAsia 2020-02-29         0         NA\n 7 AfghanistanAsia 2020-03-01         0         NA\n 8 AfghanistanAsia 2020-03-02         0         NA\n 9 AfghanistanAsia 2020-03-03         0         NA\n10 AfghanistanAsia 2020-03-04         0         NA\n# ... with 139,809 more rows\n\n\nHow could we manage to separate them? Ideally, we should provide a regular expression (or simply regex) to match the appropriate pattern to split the string into location and continent (the sep argument works with regex). If you don’t know what regex is, think of it as a code used to match patterns, positions and all kinds of features in a string.\nAt first glance, a natural choice would be to split the string as of the second uppercase letter. This would work for Afghanistan, France, Netherlands, Chile and all single-worded countries. However, this would fail for countries with two or more words: United States, New Zealand and many others.\nThen, you could argue that a more general approach would be to use regex to match the last uppercase letter in the string. Not actually, because we have a couple of two-worded continents: North America and South America. So, for example, CanadaNorth America would be split into CanadaNorth and America instead of Canada and North America.\nMore often than not, the direct solution is the most difficult to implement (or we simply don’t know how to accomplish it) and so we have to think about alternative ways. Data science is all about this. Since a regex solution alone might be very tough or even unfeasible, we’ll get back to this problem later when covering text manipulation with the stringr package.\nFor now, let’s just get done with the tidyr package looking at two other very commonly used functions. The first one is unite, which is the counterpart of separate. We can use it to convert the covid_separate data frame back to the original form as in covid_loc_cont.\n\ncovid_unite <- covid_separate %>% \n  unite(\n    col = 'location', \n    c('location', 'continent'),\n    sep = '_')\ncovid_unite\n\n# A tibble: 139,819 x 4\n   location         date       new_cases new_deaths\n   <chr>            <date>         <dbl>      <dbl>\n 1 Afghanistan_Asia 2020-02-24         5         NA\n 2 Afghanistan_Asia 2020-02-25         0         NA\n 3 Afghanistan_Asia 2020-02-26         0         NA\n 4 Afghanistan_Asia 2020-02-27         0         NA\n 5 Afghanistan_Asia 2020-02-28         0         NA\n 6 Afghanistan_Asia 2020-02-29         0         NA\n 7 Afghanistan_Asia 2020-03-01         0         NA\n 8 Afghanistan_Asia 2020-03-02         0         NA\n 9 Afghanistan_Asia 2020-03-03         0         NA\n10 Afghanistan_Asia 2020-03-04         0         NA\n# ... with 139,809 more rows\n\n\nLast but not least is the nest function. The nest function is usually used in conjunction with group_by in order to create a new format of data frame in which every cell is now a list rather than a single observation and, thus, might store any kind of object – data frames, lists, models, plots and so forth.\nThe example below shows how to create a nested data frame for the covid data grouped by country. Note that each cell on column data is now a data frame itself corresponding to the data for each country.\n\ncovid_eu_nest <- covid_data %>% \n  filter(continent == 'Europe') %>% \n  group_by(location) %>% \n  nest()\ncovid_eu_nest\n\n# A tibble: 51 x 2\n# Groups:   location [51]\n   location               data               \n   <chr>                  <list>             \n 1 Albania                <tibble [665 x 66]>\n 2 Andorra                <tibble [659 x 66]>\n 3 Austria                <tibble [665 x 66]>\n 4 Belarus                <tibble [662 x 66]>\n 5 Belgium                <tibble [686 x 66]>\n 6 Bosnia and Herzegovina <tibble [656 x 66]>\n 7 Bulgaria               <tibble [653 x 66]>\n 8 Croatia                <tibble [665 x 66]>\n 9 Cyprus                 <tibble [653 x 66]>\n10 Czechia                <tibble [663 x 66]>\n# ... with 41 more rows\n\n\nI find it most useful when we need to perform several tasks over whole data sets. For example, if we had to transform the raw data, create plots and fit models for each country in the covid data set. The base R solution in this case would be to create list of lists, which can be very confusing sometimes. We’ll come back to nested data frames when we talk about functional programming with the purrr package.\n\n\n1.3.3 Text manipulation\nThe need to handle text data has grown substantially in parallel with the popularity of Machine Learning models and, more specifically, Natural Language Processing (NLP). For those more advanced applications, the challenge is to standardize a large set of (messy) texts in order to extract features which can then feed the models and generate predictions.\nNevertheless, knowing the basics of text manipulation is critical for everyday tasks. It includes subsetting parts of a word, detecting if specific patterns are present, replacing a sequence of characters by something else and so forth. The functions from the stringr package do a terrific job in simplifying all these operations and go far beyond.\nSimilarly to what we did in the previous sections, we’ll focus on the most widely used functions. Let’s start with str_detect, which is conveniently used in conjunction with dplyr::filter since it returns TRUE if the specific pattern is found in the string or FALSE otherwise.\nFor example, let’s say we want to analyze the Covid data only for North and South Americas. We’ve learned how to do so using dplyr::filter.\n\ncovid_americas <- covid_data %>% \n  filter(continent %in% c('North America', 'South America')) \n\nThis one is not cumbersome. But let’s pretend there were, say, 50 continents on Earth with 25 having ‘America’ in their names. Would it still make sense to write all these 25 names in a vector? Absolutely not. Since all of them share a common pattern, we can easily employ str_detect to do the trick.\n\ncovid_americas <- covid_data %>% \n  filter(stringr::str_detect(continent, 'America'))\n\nNote that we could have left aside several characters using only, say, ‘Am’ or ‘Ame’. This would have worked fine if there was no other continent with this sequence of characters. Of course, this parsimony makes more sense for lengthy words or long sentences. For short words I recommended you to write the full word in order to prevent any undesirable output.\nIn addition, we can also provide multiple patterns to str_detect by separating them with a |.\n\ncovid_americas <- covid_data %>% \n  filter(stringr::str_detect(continent, 'South|North'))\n\nFinally, we may use the negate = TRUE argument if we’re interested in the opposite of the pattern we provide – pretty much like ! in conditions. It’s specially useful when we want to keep most categories but one (or a few). For example, suppose that now we want to analyze every continent except for Asia. Instead of writing them all, we could simply do the following:\n\ncovid_exAsia <- covid_data %>% \n  filter(str_detect(continent, 'Asia', negate = TRUE))\n\nAnother recurrent task when we’re dealing with strings is to remove a part of it. It’s generally required in order to establish a standard within categories so we can perform further operations. The complexity of this task vary depending on the form of this undesired part.\nThe most simple case is when we have to remove a sequence of characters which is fixed both in length and in position. For example, suppose we have a data frame covid_numCont in which the observations in the continent column starts with a random number from 0 to 9 – think of it as a typing error from the source, since the same reasoning applies if those random numbers were present only in a few observations.\n\n\n# A tibble: 10 x 4\n   continent       location                         date       new_cases\n   <chr>           <chr>                            <date>         <dbl>\n 1 2.Africa        Somalia                          2021-05-03         0\n 2 7.Asia          Qatar                            2021-02-22       463\n 3 4.Asia          Palestine                        2020-11-20      1472\n 4 7.Asia          Hong Kong                        2020-08-20        18\n 5 3.Asia          Yemen                            2020-10-21         0\n 6 7.South America Suriname                         2021-11-28        19\n 7 2.North America Saint Vincent and the Grenadines 2020-05-10         0\n 8 4.South America Colombia                         2021-05-31     23177\n 9 2.Africa        Saint Helena                     2021-02-25         0\n10 6.Africa        Gabon                            2021-05-22         0\n\n\nTo solve this is solely a matter of subsetting the string from position three onwards using str_sub. The end argument defaults to last character, so we don’t need to explicit it.\n\ncovid_numCont %>% \n  mutate(continent = str_sub(continent, start = 3))\n\n# A tibble: 139,819 x 4\n   continent location    date       new_cases\n   <chr>     <chr>       <date>         <dbl>\n 1 Asia      Afghanistan 2020-02-24         5\n 2 Asia      Afghanistan 2020-02-25         0\n 3 Asia      Afghanistan 2020-02-26         0\n 4 Asia      Afghanistan 2020-02-27         0\n 5 Asia      Afghanistan 2020-02-28         0\n 6 Asia      Afghanistan 2020-02-29         0\n 7 Asia      Afghanistan 2020-03-01         0\n 8 Asia      Afghanistan 2020-03-02         0\n 9 Asia      Afghanistan 2020-03-03         0\n10 Asia      Afghanistan 2020-03-04         0\n# ... with 139,809 more rows\n\n\nNice. But what if the random numbers ranged from 0 to 10?\n\n\n# A tibble: 10 x 4\n   continent  location     date       new_cases\n   <chr>      <chr>        <date>         <dbl>\n 1 10.Africa  Senegal      2020-09-15       223\n 2 5.Asia     Indonesia    2020-08-09      1893\n 3 5.Asia     Bangladesh   2020-10-18      1274\n 4 5.Africa   South Africa 2020-09-11      1960\n 5 10.Oceania Cook Islands 2021-08-01         0\n 6 2.Africa   Seychelles   2021-04-02        41\n 7 8.Asia     Saudi Arabia 2021-04-26       958\n 8 8.Europe   Gibraltar    2021-02-10         7\n 9 1.Asia     Oman         2020-11-11       302\n10 8.Europe   France       2021-11-16     19778\n\n\nWith an extra digit, we could no longer resort to the previous solution. We won’t dedicate an exclusive section to regular expressions, but simple examples will eventually show up throughout the book. In this case, we could use a simple regular expression inside str_remove to get rid of everything before and up to the ., .*\\\\..\n\ncovid_numCont %>% \n  mutate(continent = str_remove(continent, \".*\\\\.\"))\n\n# A tibble: 139,819 x 4\n   continent location    date       new_cases\n   <chr>     <chr>       <date>         <dbl>\n 1 Asia      Afghanistan 2020-02-24         5\n 2 Asia      Afghanistan 2020-02-25         0\n 3 Asia      Afghanistan 2020-02-26         0\n 4 Asia      Afghanistan 2020-02-27         0\n 5 Asia      Afghanistan 2020-02-28         0\n 6 Asia      Afghanistan 2020-02-29         0\n 7 Asia      Afghanistan 2020-03-01         0\n 8 Asia      Afghanistan 2020-03-02         0\n 9 Asia      Afghanistan 2020-03-03         0\n10 Asia      Afghanistan 2020-03-04         0\n# ... with 139,809 more rows\n\n\nTyping errors may arise under different forms along the character column. These cases usually require a more thorough evaluation and, more often than not, the solution is to manually replace the wrong words by the correct ones. For instance, in the data frame below (named covid_typo) we can find two different typos for North America: there’s a missing h in rows 1 and 5; while there’s an extra h in rows 3 and 8.\n\n\n# A tibble: 22,308 x 4\n   continent      location date       new_cases\n   <chr>          <chr>    <date>         <dbl>\n 1 Nort America   Anguilla 2020-03-28         2\n 2 North America  Anguilla 2020-03-29         0\n 3 Northh America Anguilla 2020-03-30         0\n 4 North America  Anguilla 2020-03-31         0\n 5 Nort America   Anguilla 2020-04-01         0\n 6 North America  Anguilla 2020-04-02         1\n 7 North America  Anguilla 2020-04-03         0\n 8 Northh America Anguilla 2020-04-04         0\n 9 North America  Anguilla 2020-04-05         0\n10 North America  Anguilla 2020-04-06         0\n# ... with 22,298 more rows\n\n\nSince the data frame contains a huge number of observations, it may be present in other positions as well. We can use str_replace to fix it for the whole column.\n\ncovid_typo %>% \n  mutate(\n    continent = str_replace(continent, 'Nort America', 'North America'),\n    continent = str_replace(continent, 'Northh America', 'North America')\n  )\n\nOr we can simply pass a vector with all the replacements to the str_replace_all function.\n\ncovid_typo %>% \n  dplyr::mutate(\n    continent = stringr::str_replace_all(\n      continent, \n      c('Nort America'   = 'North America',\n        'Northh America' = 'North America')\n    )\n  )\n\nThere’s one last kind of typo we can’t help but to mention: whitespace. Whitespaces are particularly troublesome when they’re misplaced in the start/end of string or repeated inside it. Because they’re very easy to go unnoticed the stringr package contains two functions to cope with them: str_trim and str_squish. The former removes whitespaces from start/end of the string, whereas the later removes them from inside of a string.\nThe data frame below (named covid_ws) uses the same example as above, but now with a whitespace in the end of observations 1 and 5; and a repeated whitespace inside the observations 3 and 8. Note that tibble automatically adds quotation marks around the strings to highlight the extra whitespaces. This is awesome!\n\n\n# A tibble: 22,308 x 4\n   continent        location date       new_cases\n   <chr>            <chr>    <date>         <dbl>\n 1 \"North America \" Anguilla 2020-03-28         2\n 2 \"North America\"  Anguilla 2020-03-29         0\n 3 \"North  America\" Anguilla 2020-03-30         0\n 4 \"North America\"  Anguilla 2020-03-31         0\n 5 \"North America \" Anguilla 2020-04-01         0\n 6 \"North America\"  Anguilla 2020-04-02         1\n 7 \"North America\"  Anguilla 2020-04-03         0\n 8 \"North  America\" Anguilla 2020-04-04         0\n 9 \"North America\"  Anguilla 2020-04-05         0\n10 \"North America\"  Anguilla 2020-04-06         0\n# ... with 22,298 more rows\n\n\nWe can easily get rid of the whitespaces using those functions. It’s advisable to use them as a preprocessing step whenever we’re working with character columns that should not have these extra whitespaces.\n\n#! eval: FALSE\ncovid_ws %>% \n  dplyr::mutate(\n    continent = continent %>% \n      str_trim() %>% \n      str_squish()\n  )\n\n# A tibble: 22,308 x 4\n   continent     location date       new_cases\n   <chr>         <chr>    <date>         <dbl>\n 1 North America Anguilla 2020-03-28         2\n 2 North America Anguilla 2020-03-29         0\n 3 North America Anguilla 2020-03-30         0\n 4 North America Anguilla 2020-03-31         0\n 5 North America Anguilla 2020-04-01         0\n 6 North America Anguilla 2020-04-02         1\n 7 North America Anguilla 2020-04-03         0\n 8 North America Anguilla 2020-04-04         0\n 9 North America Anguilla 2020-04-05         0\n10 North America Anguilla 2020-04-06         0\n# ... with 22,298 more rows\n\n\nTo finish up, let’s use the tools we’ve just learned to solve that problem in the previous subsection. To recap, we wanted to separate the column location into country and continent. The issue was that with no separator character between the two names, we should resort to any kind of complicated regular expression to do the trick.\n\n\n# A tibble: 139,819 x 4\n   location        date       new_cases new_deaths\n   <chr>           <date>         <dbl>      <dbl>\n 1 AfghanistanAsia 2020-02-24         5         NA\n 2 AfghanistanAsia 2020-02-25         0         NA\n 3 AfghanistanAsia 2020-02-26         0         NA\n 4 AfghanistanAsia 2020-02-27         0         NA\n 5 AfghanistanAsia 2020-02-28         0         NA\n 6 AfghanistanAsia 2020-02-29         0         NA\n 7 AfghanistanAsia 2020-03-01         0         NA\n 8 AfghanistanAsia 2020-03-02         0         NA\n 9 AfghanistanAsia 2020-03-03         0         NA\n10 AfghanistanAsia 2020-03-04         0         NA\n# ... with 139,809 more rows\n\n\nAs I said earlier, data science is all about finding workarounds. Of course we’re often interested in general approaches, but sometimes we have to settle for a lower level solution which gets the job done. For example, in this case we could waste a long time figuring out the best possible solution whereas a simpler one is at hand.\nThe simpler solution consists of employing the str_extract function to extract the name of the continents in conjunction with str_remove to remove them from the original column. Remember that multiple patterns should be provided as a single string with these patterns separated by `|’.\n\ncontinents <- c(\n  'Asia',\n  'Europe',\n  'Africa', \n  'South America',\n  'North America',\n  'Oceania'\n) %>% \n  paste0(collapse = '|')\ncovid_loc_cont2 %>% \n  mutate(\n    continent = str_extract(\n      location,\n      continents\n    ),\n    location = str_remove(\n      location,\n      continents\n    )\n  )\n\n# A tibble: 139,819 x 5\n   location    date       new_cases new_deaths continent\n   <chr>       <date>         <dbl>      <dbl> <chr>    \n 1 Afghanistan 2020-02-24         5         NA Asia     \n 2 Afghanistan 2020-02-25         0         NA Asia     \n 3 Afghanistan 2020-02-26         0         NA Asia     \n 4 Afghanistan 2020-02-27         0         NA Asia     \n 5 Afghanistan 2020-02-28         0         NA Asia     \n 6 Afghanistan 2020-02-29         0         NA Asia     \n 7 Afghanistan 2020-03-01         0         NA Asia     \n 8 Afghanistan 2020-03-02         0         NA Asia     \n 9 Afghanistan 2020-03-03         0         NA Asia     \n10 Afghanistan 2020-03-04         0         NA Asia     \n# ... with 139,809 more rows\n\n\nJob done! Next we turn to dates, which is a special form of string. Handling them properly is essential to analyze time series data.\n\n\n1.3.4 Date manipulation\nHaving knowledge on date manipulation is crucial to perform a lot of tasks when we’re dealing with time series data. Date objects are very convenient since they allow us to extract features that can be used for many purposes. The subject is so vast that tidyverse has developed the lubridate package exclusively to handle date objects.\nThe first step when we’re working with dates is to convert the string to a date object. In order to get rid of ambiguity issues, lubridate contains a set of predefined functions that take into account the ordering of year, month and day in the string.\nFor instance, if we have a date in the standard YYYY-MM-DD format we can use the ymd function. Note that it works regardless of how these terms are separated: it might be like 2021-12-01, 2022/12/01 or even 20221201. Also, months names (full or abbreviated forms) are allowed: 2021-December-01 or 2021-Dec-01. The same logic applies to the whole family of related functions: mdy, dmy, ydm, dym, my, ym and so on.\n\nlibrary(lubridate)\nymd('2022/12/01')\n\n[1] \"2022-12-01\"\n\nmdy('december, 1, 2022')\n\n[1] \"2022-12-01\"\n\ndmy('01122022')\n\n[1] \"2022-12-01\"\n\nmy('Dec-2021')\n\n[1] \"2021-12-01\"\n\n\nIn case the string format doesn’t match any of the predefined patterns, we can use lubridate::as_date function and declare the unusual format using specific operators: %Y for year; %m for month; and %d for day. There are two other useful ones: %b for months names (full or abbreviated) and %y for two-digits year.\nNow, let’s see how to extract features from date objects and how to use them to perform common operations. Take the following data set (named brl_usd) which provides daily values of the Brazilian Real (BRL) versus the US Dollar from January 2010 to December 2021 where the column date is in the DD/MM/YYYY format.\n\n\n# A tibble: 3,014 x 2\n   date        brl\n   <chr>     <dbl>\n 1 4/1/2010   1.72\n 2 5/1/2010   1.72\n 3 6/1/2010   1.73\n 4 7/1/2010   1.74\n 5 8/1/2010   1.74\n 6 11/1/2010  1.73\n 7 12/1/2010  1.74\n 8 13/1/2010  1.74\n 9 14/1/2010  1.76\n10 15/1/2010  1.77\n# ... with 3,004 more rows\n\n\nNote that the column date is in standard string (or character) format. We’ll first convert it to the appropriate date format using the functions we’ve just learned.\n\nbrl_usd_aux <- brl_usd %>% \n  mutate(date = dmy(date))\nbrl_usd_aux\n\n# A tibble: 3,014 x 2\n   date         brl\n   <date>     <dbl>\n 1 2010-01-04  1.72\n 2 2010-01-05  1.72\n 3 2010-01-06  1.73\n 4 2010-01-07  1.74\n 5 2010-01-08  1.74\n 6 2010-01-11  1.73\n 7 2010-01-12  1.74\n 8 2010-01-13  1.74\n 9 2010-01-14  1.76\n10 2010-01-15  1.77\n# ... with 3,004 more rows\n\n\nNow, suppose we want to obtain BRL monthly average. We have two ways to do this, one that is more logical and one that is more compact (see later when we talk about rounding dates). In the logical way, all we have to do is to create the columns we need to perform a grouping operation: year and month.\n\nbrl_usd_monthly <- brl_usd_aux %>% \n  mutate(\n    year  = year(date),\n    month = month(date)\n  ) %>% \n  group_by(year, month) %>% \n  summarise(brl_monthly = mean(brl))\n\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n\nbrl_usd_monthly\n\n# A tibble: 144 x 3\n# Groups:   year [12]\n    year month brl_monthly\n   <dbl> <dbl>       <dbl>\n 1  2010     1        1.78\n 2  2010     2        1.84\n 3  2010     3        1.79\n 4  2010     4        1.76\n 5  2010     5        1.81\n 6  2010     6        1.81\n 7  2010     7        1.77\n 8  2010     8        1.76\n 9  2010     9        1.72\n10  2010    10        1.68\n# ... with 134 more rows\n\n\nYou might be wondering how to recover the date format YYYY-MM-DD. We can do it by simply using the make_date function. This function creates a standard date object from user-provided year, month and day. Since we’ve aggregated daily into monthly, we have two common choices for the day parameter: we either set it to 1 (the default) or we set it to the last day of the month using days_in_month.\n\nbrl_usd_monthly %>% \n  mutate(\n    date = make_date(\n      year  = year, \n      month = month, \n      day   = 1),\n    date2 = make_date(\n      year = year, \n      month = month,\n      day   = days_in_month(date)\n    )\n  )\n\n# A tibble: 144 x 5\n# Groups:   year [12]\n    year month brl_monthly date       date2     \n   <dbl> <dbl>       <dbl> <date>     <date>    \n 1  2010     1        1.78 2010-01-01 2010-01-31\n 2  2010     2        1.84 2010-02-01 2010-02-28\n 3  2010     3        1.79 2010-03-01 2010-03-31\n 4  2010     4        1.76 2010-04-01 2010-04-30\n 5  2010     5        1.81 2010-05-01 2010-05-31\n 6  2010     6        1.81 2010-06-01 2010-06-30\n 7  2010     7        1.77 2010-07-01 2010-07-31\n 8  2010     8        1.76 2010-08-01 2010-08-31\n 9  2010     9        1.72 2010-09-01 2010-09-30\n10  2010    10        1.68 2010-10-01 2010-10-31\n# ... with 134 more rows\n\n\nNote that creating a column with the number of days in each month may be itself particularly useful. For instance, when we have only the monthly totals of a variable and we need to compute daily averages. And, of course, it works fine with February since it takes the year into account.\nThe same procedure applies if we want to get quarterly means. It’s just a matter of creating a column with quarters. Be aware, however, that the quarter function has a parameter named with_year that when is set to TRUE eliminates the need to create a separate column for the year.\n\nbrl_usd_quarterly <- brl_usd_aux %>% \n  mutate(quarter = quarter(date, with_year = TRUE)) %>% \n  group_by(quarter) %>% \n  summarise(brl_quarterly = mean(brl))\nbrl_usd_quarterly\n\n# A tibble: 48 x 2\n   quarter brl_quarterly\n     <dbl>         <dbl>\n 1   2010.          1.80\n 2   2010.          1.79\n 3   2010.          1.75\n 4   2010.          1.70\n 5   2011.          1.67\n 6   2011.          1.60\n 7   2011.          1.64\n 8   2011.          1.80\n 9   2012.          1.77\n10   2012.          1.96\n# ... with 38 more rows\n\n\nSpecial attention must be taken when we want to work with weeks, because lubridate has two different functions to extract this feature: week and isoweek. The former returns the number of complete seven day periods that have occurred between the date and January 1st, while the latter returns the number of the week (from Monday to Sunday) the date belongs to.\nTo get a better sense of the difference between them, suppose we provide the date ‘2022-01-01’. week will return 1, since it’s in the first seven days period after January 1st. On the other hand, isoweek will return 52 because it’s Saturday and thus part of the last week of the previous year. It’ll only return 1 as of ‘2022-01-03’ since it belongs to a new week.\n\nweek('2022-01-01')\n\n[1] 1\n\nisoweek('2022-01-01')\n\n[1] 52\n\nisoweek('2022-01-03')\n\n[1] 1\n\n\nTherefore, if we want to compute weekly averages and by weekly we mean a period of seven days in a row then we should pick isoweek instead of week. Another feature we can extract from dates is the week day. In addition to temporal aggregation, it’s often used to filter or label data we want to plot later.\n\nbrl_usd_aux %>% \n  mutate(wday = wday(date, label = TRUE))\n\n# A tibble: 3,014 x 3\n   date         brl wday \n   <date>     <dbl> <ord>\n 1 2010-01-04  1.72 seg  \n 2 2010-01-05  1.72 ter  \n 3 2010-01-06  1.73 qua  \n 4 2010-01-07  1.74 qui  \n 5 2010-01-08  1.74 sex  \n 6 2010-01-11  1.73 seg  \n 7 2010-01-12  1.74 ter  \n 8 2010-01-13  1.74 qua  \n 9 2010-01-14  1.76 qui  \n10 2010-01-15  1.77 sex  \n# ... with 3,004 more rows\n\n\nNow we turn to operations with date objects. The lubridate package contains two special operators %m+% and %m-% that work nicely with date objects to perform, respectively, addition and subtraction.\n\nd1 <- ymd('2020-02-29')\nd1 %m+% years(2)\n\n[1] \"2022-02-28\"\n\nd1 %m-% months(3)\n\n[1] \"2019-11-29\"\n\nd1 %m+% days(1)\n\n[1] \"2020-03-01\"\n\n\nIn addition, there’s also the lesser known add_with_rollback function which we can use to have more control of the output. For example, when adding one month to 2022-01-31 we might want either 2022-02-28 (the last day of the next month) or 2022-03-01 (a period of one month). To get the latter, we set the roll_to_first parameter to TRUE.\n\nd2 <- ymd('2022-01-31')\nadd_with_rollback(d2, months(1), roll_to_first = TRUE)\n\n[1] \"2022-03-01\"\n\nadd_with_rollback(d2, months(1), roll_to_first = FALSE)\n\n[1] \"2022-02-28\"\n\n\nI couldn’t help but mentioning two useful functions used to round dates: floor_date and ceiling_date. They take a date object and rounds it down or up, respectively, to the nearest boundary of the specified time unit.\n\nd3 <- ymd('2021-03-13')\nfloor_date(d3, unit = 'month')\n\n[1] \"2021-03-01\"\n\nceiling_date(d3, unit = 'month')\n\n[1] \"2021-04-01\"\n\nfloor_date(d3, unit = 'quarter')\n\n[1] \"2021-01-01\"\n\nceiling_date(d3, unit = 'quarter')\n\n[1] \"2021-04-01\"\n\n\nThese functions can be helpful in several ways and you’ll find their benefits as you go through your own tasks. For example, if we want to match (or re-write) dates that refer to the same period but are written differently (monthly date in data set A is ‘2021-12-01’ and in data set B is ‘2021-12-31’).\nI use them very often as a simpler way to perform temporal aggregation. Remember that earlier in this section we computed monthly averages by creating two grouping columns, year and month. The logic was simply to treat every day in the same year/month as belonging to the same group. We can easily accomplish the same result by rounding dates down, with the great benefit of preserving the date column.\n\nbrl_usd_monthly2 <- brl_usd_aux %>% \n  mutate(date = floor_date(date, unit = 'month')) %>% \n  group_by(date) %>% \n  summarise(brl_monthly = mean(brl))\nbrl_usd_monthly2\n\n# A tibble: 144 x 2\n   date       brl_monthly\n   <date>           <dbl>\n 1 2010-01-01        1.78\n 2 2010-02-01        1.84\n 3 2010-03-01        1.79\n 4 2010-04-01        1.76\n 5 2010-05-01        1.81\n 6 2010-06-01        1.81\n 7 2010-07-01        1.77\n 8 2010-08-01        1.76\n 9 2010-09-01        1.72\n10 2010-10-01        1.68\n# ... with 134 more rows\n\n\nTo finish up, let’s have a quick look at a family of functions: wday, mday, qday and yday. They’re used to get the number of days that have occurred within that time period, respectively.\n\nwday('2021-06-10') # 5th day of that week\n\n[1] 5\n\nqday('2021-06-10') # 71th day of the 2nd quarter of 2021\n\n[1] 71\n\nyday('2021-06-10') # 161th day of 2021\n\n[1] 161\n\n\nIt’s very useful, for example, when you need to compare observations from the same period in different years or create high frequency seasonal variables."
  },
  {
    "objectID": "ds_tidyverse.html#looping",
    "href": "ds_tidyverse.html#looping",
    "title": "1  Introduction",
    "section": "1.4 Looping",
    "text": "1.4 Looping\nIteration is an indispensable tool in programming and every language has its own structure. Essentially, loops are used to repeat an action over a set of values, thus preventing us from the annoying and risky copying-and-pasting thing. Whenever we have any kind of redundancy, there’s a good reason to use loops.\nThe purrr package provides many interesting tools for working with functions and vectors. For our purposes, we’ll stick with the family of map functions. The logic will be always the same: applying a function – existing or user-defined – over a vector (or list) of arguments.\nLet’s start with a very simple example. Suppose we have three numeric vectors and we want to compute their means. Instead of calling mean over each vector separately, we can put them into a list and then use the map function in conjunction with the existing mean function.\n\nv1 <- c(1,4,7,8)\nv2 <- c(3,5,9,0) \nv3 <- c(12,0,7,1)\nv_all <- list(v1, v2, v3)\nmap(.x = v_all, .f = mean)\n\n[[1]]\n[1] 5\n\n[[2]]\n[1] 4.25\n\n[[3]]\n[1] 5\n\n\nNote that by default the output will be a list, but we can have other output formats using map_*: map_dbl will return the results as a vector, whereas map_dfc will return them in a (column) data frame. We only need to consider whether or not the output can be coerced to the desired class/format.\n\nmap_dbl(.x = v_all, .f = mean)\n\n[1] 5.00 4.25 5.00\n\nmap_dfc(.x = v_all, .f = mean)\n\nNew names:\n* `` -> `...1`\n* `` -> `...2`\n* `` -> `...3`\n\n\n# A tibble: 1 x 3\n   ...1  ...2  ...3\n  <dbl> <dbl> <dbl>\n1     5  4.25     5\n\n\nMost of the time I prefer to return the results as a list, because that makes it easier to apply further operations if needed. Data frames are usually a better choice for final results.\nNow, let’s introduce some degree of complexity to the exercise by providing our own function. For this, let’s use the example of importing data from an API we saw earlier in subsection @ref(import). Suppose that in addition to CPI we also want to get the time series for GDP and Unemployment rate.\nRemember (or scroll up if necessary) that we created an object called api_series_id with the ID of the CPI time series and that was the only specific parameter – everything else would be the same for any other series we wanted. Therefore, our first task here is to create a function whose only parameter is the series ID. Then, we create a vector (or list) with the desired series ID’s and – guess what? – use them inside the map function.\nI’ll create the get_series function using the same content we already saw up there, but leaving the api_series_id as a parameter (series_id). Note that I’ll keep some objects with their original names – starting with cpi_ – just to avoid confusion. This has no practical effect, though.\n\nget_series <- function(series_id){\n  api_url       <- 'https://api.stlouisfed.org/fred/series/observations?'\n  api_key       <- 'bc0b91e1c6fa2cab4d4f180c7965edfa'\n  api_series_id <- series_id\n  obs_start     <- '2010-01-01'\n  api_filetype  <- 'json'\n  api_request   <- glue::glue('{api_url}series_id={api_series_id}&observation_start={obs_start}&api_key={api_key}&file_type={api_filetype}')\n  cpi_request   <- httr::GET(url = api_request)\n  cpi_content   <- httr::content(cpi_request, as = 'text')\n  cpi_list      <- jsonlite::fromJSON(cpi_content, flatten = FALSE)\n  cpi_tbl       <- cpi_list[['observations']] %>% tibble::as_tibble()\n  return(cpi_tbl)\n} \n\nWe can test our function using the CPI’s ID we used before.\n\nget_series(series_id = 'CPALTT01USM657N')\n\n# A tibble: 157 x 4\n   realtime_start realtime_end date       value              \n   <chr>          <chr>        <chr>      <chr>              \n 1 2023-04-04     2023-04-04   2010-01-01 0.34174735701485   \n 2 2023-04-04     2023-04-04   2010-02-01 0.024920738207648  \n 3 2023-04-04     2023-04-04   2010-03-01 0.410628353657108  \n 4 2023-04-04     2023-04-04   2010-04-01 0.173688491069743  \n 5 2023-04-04     2023-04-04   2010-05-01 0.0775197354237721 \n 6 2023-04-04     2023-04-04   2010-06-01 -0.0976267084673888\n 7 2023-04-04     2023-04-04   2010-07-01 0.0211043057371509 \n 8 2023-04-04     2023-04-04   2010-08-01 0.138066427840807  \n 9 2023-04-04     2023-04-04   2010-09-01 0.0581736230715569 \n10 2023-04-04     2023-04-04   2010-10-01 0.124519888847696  \n# ... with 147 more rows\n\n\nGreat, it’s working fine! The next step is to create a vector (or list) with the IDs of each series. Assigning names to the vector (list) elements is a good idea since these names are carried forward helping to identify the elements in the output list.\n\nid_list <- list(\n  'CPI'   = 'CPALTT01USM657N',\n  'GDP'   = 'GDPC1',\n  'Unemp' = 'UNRATE'\n)\nfred_data <- purrr::map(.x = id_list, .f = get_series)\nfred_data\n\n$CPI\n# A tibble: 157 x 4\n   realtime_start realtime_end date       value              \n   <chr>          <chr>        <chr>      <chr>              \n 1 2023-04-04     2023-04-04   2010-01-01 0.34174735701485   \n 2 2023-04-04     2023-04-04   2010-02-01 0.024920738207648  \n 3 2023-04-04     2023-04-04   2010-03-01 0.410628353657108  \n 4 2023-04-04     2023-04-04   2010-04-01 0.173688491069743  \n 5 2023-04-04     2023-04-04   2010-05-01 0.0775197354237721 \n 6 2023-04-04     2023-04-04   2010-06-01 -0.0976267084673888\n 7 2023-04-04     2023-04-04   2010-07-01 0.0211043057371509 \n 8 2023-04-04     2023-04-04   2010-08-01 0.138066427840807  \n 9 2023-04-04     2023-04-04   2010-09-01 0.0581736230715569 \n10 2023-04-04     2023-04-04   2010-10-01 0.124519888847696  \n# ... with 147 more rows\n\n$GDP\n# A tibble: 52 x 4\n   realtime_start realtime_end date       value    \n   <chr>          <chr>        <chr>      <chr>    \n 1 2023-04-04     2023-04-04   2010-01-01 15456.059\n 2 2023-04-04     2023-04-04   2010-04-01 15605.628\n 3 2023-04-04     2023-04-04   2010-07-01 15726.282\n 4 2023-04-04     2023-04-04   2010-10-01 15807.995\n 5 2023-04-04     2023-04-04   2011-01-01 15769.911\n 6 2023-04-04     2023-04-04   2011-04-01 15876.839\n 7 2023-04-04     2023-04-04   2011-07-01 15870.684\n 8 2023-04-04     2023-04-04   2011-10-01 16048.702\n 9 2023-04-04     2023-04-04   2012-01-01 16179.968\n10 2023-04-04     2023-04-04   2012-04-01 16253.726\n# ... with 42 more rows\n\n$Unemp\n# A tibble: 158 x 4\n   realtime_start realtime_end date       value\n   <chr>          <chr>        <chr>      <chr>\n 1 2023-04-04     2023-04-04   2010-01-01 9.8  \n 2 2023-04-04     2023-04-04   2010-02-01 9.8  \n 3 2023-04-04     2023-04-04   2010-03-01 9.9  \n 4 2023-04-04     2023-04-04   2010-04-01 9.9  \n 5 2023-04-04     2023-04-04   2010-05-01 9.6  \n 6 2023-04-04     2023-04-04   2010-06-01 9.4  \n 7 2023-04-04     2023-04-04   2010-07-01 9.4  \n 8 2023-04-04     2023-04-04   2010-08-01 9.5  \n 9 2023-04-04     2023-04-04   2010-09-01 9.5  \n10 2023-04-04     2023-04-04   2010-10-01 9.4  \n# ... with 148 more rows\n\n\nWe could make our function more general by allowing more parameters to vary. For example, we could have a different time span for each series (the obs_start object). The procedure would be almost the same: we would add an extra parameter in the function, create two vectors (lists) with the parameters values and use map2 instead of map.\n\nget_series2par <- function(series_id, series_start){\n  api_url       <- 'https://api.stlouisfed.org/fred/series/observations?'\n  api_key       <- 'bc0b91e1c6fa2cab4d4f180c7965edfa'\n  api_series_id <- series_id\n  obs_start     <- series_start\n  api_filetype  <- 'json'\n  api_request   <- glue::glue('{api_url}series_id={api_series_id}&observation_start={obs_start}&api_key={api_key}&file_type={api_filetype}')\n  cpi_request   <- httr::GET(url = api_request)\n  cpi_content   <- httr::content(cpi_request, as = 'text')\n  cpi_list      <- jsonlite::fromJSON(cpi_content, flatten = FALSE)\n  cpi_tbl       <- cpi_list[['observations']] %>% tibble::as_tibble()\n  return(cpi_tbl)\n} \n\ntime_list <- list(\n  'CPI'   = '2010-01-01',\n  'GDP'   = '2012-04-01',\n  'Unemp' = '2014-06-01'\n  )  \nfred_data2 <- purrr::map2(.x = id_list, .y = time_list, .f = get_series2par)\n\nWe must be careful with the example above because it may give the impression that map2 takes into account the variables names in the process. It doesn’t! It actually considers how elements are sorted in each list. So if we changed the CPI to the second position in time_list, then we would end up with GDP data with CPI time span.\nA safer, thus preferable, alternative is to use names rather than positions as indexes. Since we can use list[['element_name']] to access an element in a list, we may reduce our problem to a single dimension by looping over variables names which are the same in both lists.\n\nvars_fred <- c('CPI', 'GDP', 'Unemp')\nfred_data2_names <- map(\n  .x = vars_fred, \n  .f = function(x) get_series2par(series_id = id_list[[x]],\n                               series_start = time_list[[x]]\n  )\n) %>% \n  magrittr::set_names(vars_fred)\n\nNotice how powerful this solution is: you can generalize it to as many parameters as you need without taking the risk of using the parameter value of one series into another, with the additional work being only to make explicit the parameters of the function in .f.\nTo finish this topic, let’s get back to the end of subsection @ref(datalay). There, we had an overview of nested data frames and I stated that I find them most useful when we need to perform several tasks over whole data sets. Also, remember that nesting a data frame is, roughly speaking, converting every cell from a single observation into a list.\nLet’s print again the nested data frame we created up there, named covid_eu_nest.\n\n\n# A tibble: 51 x 2\n# Groups:   location [51]\n   location               data               \n   <chr>                  <list>             \n 1 Albania                <tibble [665 x 66]>\n 2 Andorra                <tibble [659 x 66]>\n 3 Austria                <tibble [665 x 66]>\n 4 Belarus                <tibble [662 x 66]>\n 5 Belgium                <tibble [686 x 66]>\n 6 Bosnia and Herzegovina <tibble [656 x 66]>\n 7 Bulgaria               <tibble [653 x 66]>\n 8 Croatia                <tibble [665 x 66]>\n 9 Cyprus                 <tibble [653 x 66]>\n10 Czechia                <tibble [663 x 66]>\n# ... with 41 more rows\n\n\nWe can use map to perform computations for every country at once. Moreover, we can create new columns to store the results, thus gathering all the information in the same object.\n\ncovid_eu_nest %>% \n  mutate(\n    max_total_cases = map_dbl(\n      .x = data, \n      .f = function(x){\n        x %>% \n          pull(total_cases) %>% \n          max(na.rm = TRUE)}\n    ),\n    min_total_cases = map_dbl(\n      .x = data, \n      .f = function(x){\n        x %>% \n          pull(total_cases) %>% \n          min(na.rm = TRUE)}\n    )\n  ) %>% View()\n\nAnd since each cell is a list rather than an observation, we’re by no means restricted to numeric elements. We could use the same strategy to create a column with plots, for example. Plotting is, by the way, the subject of the next section."
  },
  {
    "objectID": "ds_tidyverse.html#plotting",
    "href": "ds_tidyverse.html#plotting",
    "title": "1  Introduction",
    "section": "1.5 Plotting",
    "text": "1.5 Plotting\nWe’re almost there in our goal to review the basics of Tidyverse. Succinctly describing all the previous sections was challenging, but I believe you had enough information to start carrying out data analyzes on your own. When it comes to making graphics, extrapolating from the basics is somewhat harder because there are infinite possibilities for customization.\nIn fact, the grammar used in ggplot2 package is broad and far from simple at first glance. But as you practice, it becomes increasingly graspable. Still, I encourage you to dive into the the amazing Wickham, Navarro, and Pedersen (2019) since getting fluent on this subject is indispensable.\nLet’s think about the process of making a graphic as a set of layers arranged sequentially. The first layer is the data you want to plot. We’ll use the CPI data from subsection @ref(readapi). The second layer is the ggplot function. So far, there’s nothing to visualize. All these two layers do is to set the stage for what’s coming next.\n\ncpi_tbl %>% \n  ggplot()\n\nThe third layer we must provide is the geom, which is the geometry used to represent our data. This is the most important layer as it contains a set of parameters that effectively creates a visualization of the data. For time series data we generally use a line graph, so geom_line is the appropriate geometry. In addition, we need to provide the values for x and y axes. In this case, they’re the dates and CPI values, respectively.\nBefore proceeding, we need to make sure that the values for x and y are in the appropriate format (or class). We can use the glimpse function from dplyr package to check this out.\n\ncpi_tbl %>%\n  glimpse()\n\nRows: 156\nColumns: 4\n$ realtime_start <chr> \"2023-04-04\", \"2023-04-04\", \"2023-04-04\", \"2023-04-04\",~\n$ realtime_end   <chr> \"2023-04-04\", \"2023-04-04\", \"2023-04-04\", \"2023-04-04\",~\n$ date           <chr> \"2010-01-01\", \"2010-02-01\", \"2010-03-01\", \"2010-04-01\",~\n$ value          <chr> \"0.34174735701485\", \"0.024920738207648\", \"0.41062835365~\n\n\nWe see that both date and value (the CPI value) are in character format and so we need to convert them to date and numeric format, respectively. One last thing we need to be aware of is that ggplot uses + instead of %>% as an operator to chain actions. Therefore, every layer we add is preceded by a +. The code below produces the simplest plot from CPI data.\n\ncpi_tbl %>%\n  mutate(\n    date  = ymd(date),\n    value = as.numeric(value)\n  ) %>% \n  ggplot() + \n  geom_line(aes(x = date, y = value))\n\n\n\n\nWhat should we care about this plot? Well, every plot must contain a meaningful title and labels for both x and y axes. We can set them using the labs layer. Additionally, we might want to have shorter intervals for dates (x-axis) and values (y-axis). There are also specific layers to control axes settings.\n\ncpi_tbl %>%\n  mutate(\n    date = ymd(date),\n    value = as.numeric(value)\n  ) %>% \n  ggplot() + \n  geom_line(aes(x = date, y = value)) +\n  labs(\n    title = 'US CPI showing an upward trend as of 2021',\n    x     = 'Date',\n    y     = 'US Monthly CPI (%)'\n  ) +\n  scale_x_date(date_breaks = '1 year', date_labels = '%Y') +\n  scale_y_continuous(breaks = seq(-1, 1.5, 0.25), limits = c(-1,1.5))\n\n\n\n\nFinally, we could be interested in adding some feature to the plot in order to highlight the upward trend as of 2021. Either the 12-month-accumulated CPI or the 3-months-accumulated seasonally-adjusted CPI would be common choices for the task and we’ll see examples of how to perform this kind of computation later. For now, just to keep things simple let’s use the average CPI from 2010 to 2019 (the pre-COVID period) as a measure of ‘normal’ CPI.\n\ncpi_tbl %>%\n  mutate(\n    date = ymd(date),\n    value = as.numeric(value)\n  ) %>% \n  mutate(value_avg = mean(value[which(year(date) %in% 2010:2019)])) %>% \n  ggplot() + \n  geom_line(aes(x = date, y = value)) +\n  geom_line(aes(x = date, y = value_avg), color = 'red', lwd = 1) +\n  labs(\n    title    = 'US CPI showing an upward trend as of 2021',\n    subtitle = 'Red line is the 2010-2019 average',\n    x        = 'Date',\n    y        = 'US Monthly CPI (%)'\n  ) +\n  scale_x_date(date_breaks = '1 year', date_labels = '%Y') +\n  scale_y_continuous(breaks = seq(-1, 1, 0.25))\n\n\n\n\nSince the parameter x = date appears in both geom_line layers, we could make the code more compact by moving this parameter to ggplot() function. All the parameters inside ggplot() are carried forward to every subsequent layer. It saves a lot of effort when we’re adding geom_*’s to a graphic with fixed features. In this graphic, x will always be the date variable regardless of any layer I insert on it.\n\ncpi_tbl %>%\n  mutate(\n    date = ymd(date),\n    value = as.numeric(value)\n  ) %>% \n  mutate(value_avg = mean(value[which(year(date) %in% 2010:2019)])) %>% \n  ggplot(aes(x = date)) + \n  geom_line(aes(y = value)) +\n  geom_line(aes(y = value_avg), color = 'red', lwd = 1) +\n  labs(\n    title    = 'US CPI showing an upward trend as of 2021',\n    subtitle = 'Red line is the 2010-2019 average',\n    x        = 'Date',\n    y        = 'US Monthly CPI (%)'\n  ) +\n  scale_x_date(date_breaks = '1 year', date_labels = '%Y') +\n  scale_y_continuous(breaks = seq(-1, 1.5, 0.25), limits = c(-1, 1.5))\n\nYou should be asking yourself why x and y parameters went inside the aes function whereas color went outside it. First of all, the parameters which set the graphic axes always go inside aes. Other parameters have a special role whether they appear inside or outside aes. According to the documentation, aesthetic mappings describe how variables in the data are mapped to visual properties (aesthetics) of geoms. It’s much more easier to understand through an example.\nIn the graphic above, we used color outside aes to define which color we wanted for the graphic line. However, if we were to use color as an attribute to highlight different groups from the data, color should go inside aes. In addition, we should pass a variable onto it instead of color names. This variable might be discrete, in which case we would have one color per group; or it might be continuous, in which case we would have a color gradient.\nIn the piece of code below we create a new variable named covid_period to separate the CPI data between pre-Covid and Covid periods and use it as a color attribute.\n\ncpi_tbl %>%\n  mutate(\n    date  = ymd(date),\n    value = as.numeric(value),\n    covid = if_else(between(date, ymd('2020-03-01'), ymd('2022-12-01')), 'Yes', 'No')\n    ) %>%\n  ggplot() + \n  geom_line(aes(x = date, y = value, color = covid), lwd = 1) +\n  labs(\n    title    = 'US CPI showing an upward trend as of 2021',\n    x        = 'Date',\n    y        = 'US Monthly CPI (%)'\n    ) +\n  scale_x_date(date_breaks = '1 year', date_labels = '%Y') +\n  scale_y_continuous(breaks = seq(-1, 1.5, 0.25), limits = c(-1, 1.5))\n\n\n\n\nNote that ggplot automatically assigns colors for the attributes and adds a legend. So we could be interested in customize both the attributes’ colors and legend position. Again, this might be achieved by adding two specific layers. The logic will always be the same: parameters inside aes turn a variable into an attribute which might then be customized by specific layers.\n\ncpi_tbl %>%\n  mutate(\n    date  = ymd(date),\n    value = as.numeric(value),\n    covid = if_else(between(date, ymd('2020-03-01'), ymd('2022-12-01')), 'Yes', 'No')\n    ) %>% \n  ggplot() + \n  geom_line(aes(x = date, y = value, color = covid), lwd = 1) +\n  labs(\n    title    = 'US CPI showing an upward trend as of 2021',\n    x        = 'Date',\n    y        = 'US Monthly CPI (%)') +\n  scale_x_date(date_breaks = '1 year', date_labels = '%Y') +\n  scale_y_continuous(breaks = seq(-1, 1.5, 0.25), limits = c(-1, 1.5)) +\n  scale_color_manual(values = c('darkgreen', 'orange')) +\n  theme(legend.position = 'top')\n\n\n\n\nAs a final example, we’ll see how to build a scatter plot and explore some additional features from ggplot. Scatter plots are used to highlight the relationship between two variables in a given point in time. For this task, let’s take the Covid data set. We’ll first filter the data to a given point in time, say 2021-07-31. Next, we’ll plot people_fully_vaccinated_per_hundred and new_deaths_smoothed_per_million on the x and y axes, respectively.3\n\ncovid_data %>% \n  filter(date == '2021-07-31') %>% \n  ggplot() +\n  geom_point(\n    aes(\n      x = people_fully_vaccinated_per_hundred,\n      y = new_deaths_smoothed_per_million\n    )\n  )\n\nWarning: Removed 133 rows containing missing values (geom_point).\n\n\n\n\n\nWe saw earlier how to manually set the color to each group. It’s worth emphasizing that we’re by no means bounded to using colors names as ggplot also works with other tools such as HEX codes and the awesome ColorBrewer. ColorBrewer is an amazing source for color schemes carefully designed to improve visual communication. You can check this out at https://colorbrewer2.org/.\nWe’ll stick with ColorBrewer since it makes it effortless to assign a different color to each of the six continents. Notice that after choosing your desired pattern and palette in the website, you get some meta data (type and scheme) that will be used here.\nIn addition, we’ll use theme_light() to make our plot cleaner. Basically, a theme is a set of pre-defined features for a graph. You can check other built-in themes, including theme_dark(), theme_minimal(), theme_classic() and so on.\n\ncovid_data %>% \n  filter(\n    date == '2021-07-31',\n    !is.na(continent)\n  ) %>% \n  ggplot() +\n  geom_point(\n    aes(\n      x = people_fully_vaccinated_per_hundred,\n      y = new_deaths_smoothed_per_million,\n      color = continent\n    ),\n    size = 3\n  ) +\n  labs(title = 'New deaths in late July were above 5 per million people in countries where vaccination falls below 30% of population') +\n  scale_color_brewer(type = 'qual', palette = 2) +\n  theme_light()\n\nWarning: Removed 133 rows containing missing values (geom_point).\n\n\n\n\n\nTo finish, instead of showing all the continents in a single plot we could separate them in multiple panels using facet_wrap. This feature is very useful when the range of values across the groups differ greatly in magnitude.\n\ncovid_data %>% \n  filter(\n    date == '2021-07-31',\n    !is.na(continent)\n  ) %>% \n  ggplot() +\n  geom_point(\n    aes(\n      x = people_fully_vaccinated_per_hundred,\n      y = new_deaths_smoothed_per_million\n    ),\n    size = 3\n  ) +\n  labs(title = 'New deaths in late July were above 5 per million people in countries where vaccination falls below 30% of population') +\n  theme_light() +\n  facet_wrap(~ continent)\n\nWarning: Removed 133 rows containing missing values (geom_point).\n\n\n\n\n\nSince we have a separate panel for each continent, it’s no longer necessary to assign a different color for each of them. The coming chapters will bring more plotting features and tips on how to improve data visualization.\n\n\n\n\nGrolemund, G., and H. Wickham. 2017. R for Data Science, 1st Edition. O’Reilly Media.\n\n\nWickham, H., Danielle Navarro, and Thomas Lin Pedersen. 2019. Ggplot2: Elegant Graphics for Data Analysis, 3rd Edition. Springer."
  },
  {
    "objectID": "ds_googlemob.html",
    "href": "ds_googlemob.html",
    "title": "2  Additional resources",
    "section": "",
    "text": "In the introductory Chapter we saw how to import, organize and visualize data. However, little attention has been given to situations that require greater efficiency or scalability. This Chapter will take a step further in extending the previous knowledge to deal with more challenging situations.\nFor this exercise, we will use the Google Mobility data. Google started releasing this data on a daily basis right after the COVID outbreak spread across the world by mid-February 2020. Since then this data has been widely used for different purposes: from assessing/measuring economic activity to designing public policies. In spite of being a well-organized data set, it does offer the opportunity to do real-life data wrangling and to explore good practices from importing through visualizing.1"
  },
  {
    "objectID": "ds_googlemob.html#importing-data",
    "href": "ds_googlemob.html#importing-data",
    "title": "2  Additional resources",
    "section": "2.1 Importing data",
    "text": "2.1 Importing data\nGoogle offers two ways to download mobility data: you can either get a unique .csv file with all the available countries or you can get a .zip file with a separate .csv file for each country. We will stick with the latter for a simple reason: we are probably not interested in analyzing every single country and as these data sets grow larger, it’s much more efficient to import only the data for countries we are interested in.\nWe begin by downloading the .zip file to the data folder.\n\ndownload.file(\n  url  = 'https://www.gstatic.com/covid19/mobility/Region_Mobility_Report_CSVs.zip',\n  destfile = 'data/Region_Mobility_Report_CSVs.zip'\n  )\n\nNow suppose we want to analyze a small group of countries. In this case, a better approach is to only import the .csv corresponding to these countries and then bind them together. After a brief inspection of the .zip file, we can see a clear pattern in file names: year_country-code_Region_Mobility_Report.csv. For example, the file containing data for Brazil in 2021 is: 2021_BR_Region_Mobility_Report.csv.\nSo, our first task is to produce a vector with the desired file names. This vector will be used later to extract the corresponding .csv from the .zip file. We can call Sys.Date() to recover the current year and use it as the end point of our sequence of years. Whether you are reading this book in 2022 or in 2030 and Google still releases mobility data with file names following the same pattern, then you can safely use the solution below.\n\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(glue)\ncountries_codes  <- c('BR', 'US', 'DE', 'ZA', 'SG', 'AU')\nyears            <- seq(from = 2020, \n                        to = year(Sys.Date()), \n                        by = 1\n                        )\ngoogle_filenames <- \n  cross2(years, countries_codes) %>% \n  map_chr(\n    .f = ~ .x %>% \n      glue_collapse(sep = '_') %>%\n      glue('_Region_Mobility_Report.csv')\n  )\n\nThe cross2 function creates all the combinations between codes and years we need to replicate the first part of the file names. The final part is static, so it’s just a matter of pasting this piece into each element of the vector. We can check a piece of the result below:\n\n\n [1] \"2020_BR_Region_Mobility_Report.csv\" \"2021_BR_Region_Mobility_Report.csv\"\n [3] \"2022_BR_Region_Mobility_Report.csv\" \"2023_BR_Region_Mobility_Report.csv\"\n [5] \"2020_US_Region_Mobility_Report.csv\" \"2021_US_Region_Mobility_Report.csv\"\n [7] \"2022_US_Region_Mobility_Report.csv\" \"2023_US_Region_Mobility_Report.csv\"\n [9] \"2020_DE_Region_Mobility_Report.csv\" \"2021_DE_Region_Mobility_Report.csv\"\n\n\nTo finish up, we now resort to the map function to extract each file name from the .zip file. At this stage, I would like to draw your attention to something very important. Remember that we are ultimately interested in binding together all the .csv files in google_filenames. Since Google’s files contain columns for both country and date, we could safely use map_dfr to automatically stack the data – it would save us a few lines of code.\nHowever, it could well be that these files did not contain identifying columns – this information being only in the file name. It happens more often than not in real-life applications. So, if we naively stacked these files we would never be able to distinguish which country or date period each piece of the resulting data frame refers to.\nAnother issue that could cause us problems is if any of the elements in google_filenames did not exist. For example, if there wasn’t data for Germany in 2021. The map function would throw an error and interrupt the task, regardless all the other files were present. To prevent this problem, we can use the possibly function from purrr package, which replaces the error (or any side effect) with another output. In this case, we can replace the error by a NULL element in the list.\nTherefore, the efficient strategy in this case is:\n\nUse the map function to import each file as an element in a list using the possibly function to avoid any error.\nAssign meaningful names for each element of that list with set_names from magrittr package.\nCall the ldply function from plyr package to stack them.\n\nThe ldply function is very convenient here because it carries the names of the elements in the list into the resulting data frame as a new column. In addition, it also has several other useful features such as applying a generic function to each element of the list before stacking it.\nIn this example, the file names contain both the country code and year for each data set. Thankfully, we have a very simple pattern and we can extract the relevant information from the first seven characters of each element in our vector google_filenames. More complicated patterns would require the use of regular expressions.\n\nmobility_data <- \n  map(\n    .x = google_filenames, \n    .f = possibly(\n      ~ read_csv(unz('data/Region_Mobility_Report_CSVs.zip', .x)),\n      otherwise = NULL\n    )\n  ) %>% \n  set_names(str_sub(\n    google_filenames, start = 1, end = 7)\n  ) %>% \n  plyr::ldply(.id = 'year_country')"
  },
  {
    "objectID": "ds_googlemob.html#preparing-the-data",
    "href": "ds_googlemob.html#preparing-the-data",
    "title": "2  Additional resources",
    "section": "2.2 Preparing the data",
    "text": "2.2 Preparing the data\nNow the we have successfully imported the data for the selected countries, it is time to produce useful content. Let’s begin with a closer look on the structure of the data set. We can remove the year_country column since it was only for pedagogical purposes and we won’t need it.\n\n\n\n\nmobility_data %>%\n  dplyr::glimpse()\n\nRows: 4,772,663\nColumns: 15\n$ country_region_code                                <chr> \"BR\", \"BR\", \"BR\", \"~\n$ country_region                                     <chr> \"Brazil\", \"Brazil\",~\n$ sub_region_1                                       <chr> NA, NA, NA, NA, NA,~\n$ sub_region_2                                       <chr> NA, NA, NA, NA, NA,~\n$ metro_area                                         <lgl> NA, NA, NA, NA, NA,~\n$ iso_3166_2_code                                    <chr> NA, NA, NA, NA, NA,~\n$ census_fips_code                                   <chr> NA, NA, NA, NA, NA,~\n$ place_id                                           <chr> \"ChIJzyjM68dZnAARYz~\n$ date                                               <date> 2020-02-15, 2020-0~\n$ retail_and_recreation_percent_change_from_baseline <dbl> 5, 2, -2, -3, -1, 1~\n$ grocery_and_pharmacy_percent_change_from_baseline  <dbl> 4, 3, 0, -1, -2, 7,~\n$ parks_percent_change_from_baseline                 <dbl> -5, -13, -12, -11, ~\n$ transit_stations_percent_change_from_baseline      <dbl> 8, 3, 9, 9, 8, 11, ~\n$ workplaces_percent_change_from_baseline            <dbl> 6, 0, 19, 15, 14, 1~\n$ residential_percent_change_from_baseline           <dbl> 0, 1, -1, -1, -1, -~\n\n\nWe can see our data set has about 4.7 million rows and 15 columns. The most relevant information are stored in the columns ending with percent_change_from_baseline. These are precisely the measures of mobility for categorized places. The other columns of interest are those containing region and, of course, the column date. I recommend you to set some time aside to explore the data set. You will notice that the sub_region_* columns refer to regional breakdowns such as states and municipalities. They are NA for aggregate levels.\nSuppose our ultimate goal is to have a plot with the average mobility across all the categories for each country in the national-level. We know in advance that it’s very likely that a strong seasonal pattern is present. For example, mobility in workplaces should be higher on weekdays and lower on weekends. The opposite should be true for parks. Creating a 7-days rolling mean of the original time series solves the problem.\nFinally, we need to invert the residential mobility since a higher (lower) residential mobility means a lower (higher) mobility elsewhere. So, if we are to aggregate all the mobility categories into one single measure (the average) they must point to the same direction.\nHence, our task is to produce a data frame with only the relevant variables. This involves, for each country, the following sequence of actions:\n\nFilter the national data.\nInvert the direction of the residential mobility (change the sign).\nTransform each mobility category column into a 7-days moving average.\nCreate a column with the average mobility of categories.\nRemove the irrelevant variables.\n\nThis should not be quite a challenge and we can accomplish it with a few lines of code using the right features from dplyr package. I consider Items 3 and 4 the most important because we are tempted to offer a cumbersome solution that can be easily avoided with the proper tools. But before jumping to the best approach. let’s figure out how an inefficient approach might look like for Item 3. Using the roll_meanr function from the RcppRoll package to compute 7-days rolling means, our first solution could be something like this:\n\nlibrary(RcppRoll)\nmutate_try1 <- mobility_data %>% \n  group_by(country_region) %>% \n  arrange(date) %>% \n  mutate(\n    retail_and_recreation_percent_change_from_baseline = roll_meanr(retail_and_recreation_percent_change_from_baseline, 7, na.rm = TRUE),\n    grocery_and_pharmacy_percent_change_from_baseline = roll_meanr(grocery_and_pharmacy_percent_change_from_baseline, 7, na.rm = TRUE),\n    parks_percent_change_from_baseline = roll_meanr(parks_percent_change_from_baseline, 7, na.rm = TRUE),\n    transit_stations_percent_change_from_baseline = roll_meanr(transit_stations_percent_change_from_baseline, 7, na.rm = TRUE),\n    workplaces_percent_change_from_baseline = roll_meanr(workplaces_percent_change_from_baseline, 7, na.rm = TRUE),\n    residential_percent_change_from_baseline = roll_meanr(residential_percent_change_from_baseline, 7, na.rm = TRUE)\n  ) %>% \n  ungroup()\n\nThis solution is terrible, nevertheless I come across it very often. Fortunately, we already have a way to avoid it. The first step towards a better solution would be to use the across function from dplyr package to replace the variable name in the right-hand side by .x. This will eliminate part of the redundancies.\n\nlibrary(RcppRoll)\nmutate_try2 <- mobility_data %>% \n  group_by(country_region) %>% \n  arrange(date) %>% \n  mutate(\n    across(retail_and_recreation_percent_change_from_baseline, ~ roll_meanr(.x, 7)),\n    across(grocery_and_pharmacy_percent_change_from_baseline, ~ roll_meanr(.x, 7)),\n    across(parks_percent_change_from_baseline, ~ roll_meanr(.x, 7)),\n    across(transit_stations_percent_change_from_baseline, ~ roll_meanr(.x, 7)),\n    across(workplaces_percent_change_from_baseline, ~ roll_meanr(.x, 7)),\n    across(residential_percent_change_from_baseline, ~ roll_meanr(.x, 7))\n    ) %>% \n  ungroup()\n\nOk, we’ve made some progress in cutting part of the repetitions but we can certainly do better. Note that the variables we are interested in show a clear pattern: they all end with percent_change_from_baseline or simply baseline. We can take advantage of this to further improve our solution using select helpers. These are expressions that can be used to refer to specific patterns. For instance, here we could use the select helper ends_with to create the 7-days rolling mean for all the variables ending with baseline.\nIn addition, we can also use the argument .names to assign a glue-style name to the new variables: {.col} gets the column name and {.fun} gets the name of the function. This is great to identify which function we applied to each variable. Here, we can use a ma7d suffix which stands for moving-average 7-days.\n\nlibrary(RcppRoll)\nmutate_topsolution <- mobility_data %>% \n  group_by(country_region) %>% \n  arrange(date) %>% \n  mutate(across(ends_with('baseline'), ~ roll_meanr(.x, na.rm = TRUE), .names = '{.col}_ma7d')) %>% \n  ungroup()\n\nThe main lesson here is to avoid using variables names to compute the operations. Instead, whenever possible we must rely on the combination of across and select helpers. This avoids unnecessarily writing variables names so many times and therefore allows us to easily scale up the work.\nThe same reasoning applies to Item 4. Can you see how? Remember that Item 4 asks us to create a column with the average mobility across categories. Well, all these columns end with baseline. Therefore, we don’t need to rewrite all the variables names to get a new column with the mean – we can resort to select helpers. The only difference is that now we need an operation across the rows rather than across the columns.\nWe can accomplish it by using the rowwise function from dplyr package. Roughly speaking, this function turns every row of the data frame into a single group. Then you can perform your calculation on that group (the row). In addition, we have to replace the across function by the c_across function. The c_across is simply the equivalent of across when we’re using the rowwise mode. Remember to call ungroup to turn row-wise off and get back to the default column-wise mode when you don’t need operations across the rows anymore.\nBelow the full solution for Items 1 to 5.\n\nlibrary(RcppRoll)\nmobility_final <- mobility_data %>% \n  filter(is.na(sub_region_1)) %>%\n  mutate(across(starts_with('residential'), ~ -1*.x)) %>%\n  group_by(country_region) %>%\n  arrange(date) %>% \n  mutate(across(ends_with('baseline'), ~ roll_meanr(.x, 7, na.rm = TRUE), .names = '{.col}_ma7d')) %>%\n  ungroup() %>% \n  rowwise() %>% \n  mutate(avg_mobility = mean(c_across(ends_with('ma7d')), na.rm = TRUE)) %>%\n  ungroup() %>% \n  select(date, country_region, ends_with('ma7d'), avg_mobility)"
  },
  {
    "objectID": "ds_googlemob.html#plot-information",
    "href": "ds_googlemob.html#plot-information",
    "title": "2  Additional resources",
    "section": "2.3 Plot information",
    "text": "2.3 Plot information\nWe have mobility data for six countries and we should now decide how to plot them. Time series are usually better presented as lines, but there are some choices to be made. The most important one is whether we should display the countries data either as a single or in separate graphs. It depends on the purpose of the plot. If we are interested in observing the differences among countries in the same time period, then a single graph is a natural choice. On the other hand, if our goal is to observe in more detail the evolution in each country, then a separate plot is more convenient.\nLet’s stick with the latter in this example using the facet_wrap feature. In this case we’re segmenting our plot by country, but we’re not constrained to segment it by only one variable. Besides, we could use the argument scales = 'free_y' to make the scales of each graph more adjusted to the limits of the data. It’s not desirable here as we want to make visual comparisons between countries straightforward.\n\nmobility_final %>% \n  ggplot(aes(x = date, y = avg_mobility)) +\n  geom_line() +\n  facet_wrap(~ country_region) +\n  labs(title = 'Average mobility in selected countries - % change from baseline',\n       subtitle = '7-days moving average',\n       x = '',\n       y = 'Average mobility (% change from baseline)',\n       caption = 'Data source: Google') +\n  geom_hline(yintercept = 0, linetype = 2) +\n  theme_light()"
  },
  {
    "objectID": "ds_googlemob.html#from-code-to-function",
    "href": "ds_googlemob.html#from-code-to-function",
    "title": "2  Additional resources",
    "section": "2.4 From code to function",
    "text": "2.4 From code to function\nWe have written the full code to import, prepare and visualize the data. Perhaps this analysis will become part of our routine or that of a stakeholder. And if that happens, it’s desirable that we can look at other countries as well. So a good practice in this case is to wrap our code as a function.\nCreating a function is highly recommended whenever we have a repeated action on a different set of arguments. Here, we can think of three arguments that we would like to change eventually: the country, the time span and the window size of the rolling mean. Therefore our task is to gather all the code we have produced so far and to transform these three inputs into arguments of the function.\nNote, however, that converting code into a function raises some issues. For example, when writing the code we used a vector to import data for the selected countries. It’s not the most efficient approach, because each file has a significant size and thus the execution may be very slow. This is a truly concern when we’re writing a function, because functions are most of the time used to loop over a large set of arguments – many countries, for example. Hence, we would like to process this task in parallel rather than serially.\nSurely we can perform this parallel processing inside the function, but I always prefer to keep things simpler and more transparent. This means to write a function that plots only a single country and, if necessary, we can use map to get as many countries as we want – and eventually in parallel.2\nOther minor yet important issue is that in a function we have to use the arguments as inputs everywhere, not only in obvious places. For example, when preparing the data we included a ma7d to the column names to indicate they were transformed into 7-days rolling mean. This label was also used in many actions later – when computing the average mobility, in the plot subtitle, etc. Therefore, we need to ensure that this argument will be considered in those actions as well. To achieve this, we’ll use glue() function to create custom labels.\n\nplot_mobility <- function(country_code, start_date, end_date, ma_window){\n  library(lubridate)\n  library(tidyverse)  \n  library(glue)\n  # Import data\n  countries_codes <- country_code\n  years <- seq(from = 2020,\n               to   = year(Sys.Date()), \n               by   = 1)\n  google_filenames <- \n    cross2(years, countries_codes) %>% \n    map_chr(\n      .f = ~ .x %>% \n        glue_collapse(sep = '_') %>%\n        glue('_Region_Mobility_Report.csv')\n    )\n  mobility_data <- \n    map_dfr(\n      .x = google_filenames, \n      .f = possibly(\n        ~ readr::read_csv(unz('data/Region_Mobility_Report_CSVs.zip', .x)),\n        otherwise = NULL\n      )\n    )\n  # Prepare data\n  mobility_prep <- mobility_data %>% \n    filter(is.na(sub_region_1)) %>%\n    mutate(across(starts_with('residential'), ~ -1*.x)) %>%\n    group_by(country_region) %>%\n    arrange(date) %>% \n    mutate(across(ends_with('baseline'), ~ roll_meanr(.x, ma_window, na.rm = TRUE), .names = '{.col}_ma{ma_window}d')) %>%\n    ungroup() %>% \n    rowwise() %>% \n    mutate(avg_mobility = mean(c_across(ends_with(glue('ma{ma_window}d'))), na.rm = TRUE)) %>%\n    ungroup() %>% \n    select(date, country_region, ends_with('baseline'), avg_mobility) \n  # Output: plot\n  mobility_prep %>% \n    filter(between(date, ymd(start_date), ymd(end_date))) %>% \n    ggplot(aes(x = date, y = avg_mobility)) +\n    geom_line() +\n    labs(\n      title = glue('Average mobility in {country_code} - % change from baseline'),\n      subtitle = glue('{ma_window}-days moving average'),\n      caption = 'Data source: Google'\n    ) +\n    geom_hline(yintercept = 0, linetype = 2) +\n    theme_light()\n}\n\nWe can now use the function plot_mobility to plot any country we want and with the desired time span and window for the rolling mean.\n\nplot_mobility('BR', '2020-03-01', '2022-10-15', 14)\n\n\n\n\nOr we can use map to build the plot for several countries and the special operators from patchwork package 3 to arrange them in a convenient way.\n\nlibrary(patchwork)\ncountries <- c('BR', 'FR')\nmobility_countries <- map(\n  .x = countries, \n  .f = plot_mobility, \n  '2020-03-01', \n  '2022-10-15',\n  14\n  ) %>% \n  set_names(countries)\nmobility_countries[[1]] / mobility_countries[[2]]\n\n\n\n\nTo finish up, we must keep in mind that a function that return a plot is not very flexible and maybe we should consider the output to be the processed data instead of the plot. This would enable us to customize the plot and to perform other analysis as well. It’s not efficient either to download and prepare the data every time the function is called. The best solution in this case would require the processed data to be stored in a SQL data base, for instance."
  },
  {
    "objectID": "ds_seasonality.html",
    "href": "ds_seasonality.html",
    "title": "3  Seasonal adjustment",
    "section": "",
    "text": "There are some methods available for seasonal adjustment, X-13-ARIMA from the US Census Bureau being the most used. It basically makes use of a standard ARIMA model with external regressors accounting for outliers, permanent shifts, holidays and so on. In the following sections we’ll see how to identify and remove the seasonal pattern from Brazilian Retail Sales data (PMC) using X-13-ARIMA.\n\n3.0.1 Spotting a seasonal pattern\nIt’s very common for time series to show a seasonal pattern strong enough that it’s possible to identify it simply by visual inspection. The data on Brazilian Retail Sales is an example of this, as we can clearly see the regularly spaced peaks throughout the sample.\n\n\n\n\n\n\n\n\nSometimes, however, the mix of trends and random noise may hinder our ability to spot the seasonal pattern. In these cases, we can resort to some tools. For example, the ggmonthplot function from the forecast package is a nice shortcut to build a plot where the data are grouped by period and so we can get a better sense of whether values are typically higher or lower for an specific period.\n\npmc_ts_nsa %>%\n  ggmonthplot() +\n  labs(\n    title = 'Retail sales in Brazil - Volume Index (2014 = 100)',\n    x = '',\n    y = 'Index (2014 = 100)'\n  )\n\n\n\n\nAs the graph makes clear, we can expect values on December to be, on average, higher than any other month. This is obviously related to year-end sales, as you might suspect. Another great tool we can employ to discover a seasonal pattern is the mstl function from the same package. Remember it decomposes the time series into its structural components, the seasonal pattern being one of them.\n\npmc_ts_nsa %>%\n  mstl() %>% \n  autoplot() + \n  labs(\n    title = 'Retail sales in Brazil - Volume Index (2014 = 100)',\n    x = '',\n    y = 'Index (2014 = 100)'\n  )\n\n\n\n\nBreaking down the time series into its components has a clear advantage over the previous tool, since it provides additional information about each of these components. In this case, we can notice that the seasonal component has became larger as of 2010. In addition, we can see that the large one-off shock in retail sales due to COVID-19 in March of 2020 was mostly identified as random noise rather than contaminating the other components.\n\n\n3.0.2 Removing the seasonal pattern\nX-13-ARIMA is available for R users through the seasonal package. In order to make it as simple as possible, the function seas can automatically select the model that fits the data best. Therefore, we can perform seasonal adjustment without any specific knowledge. Notice that the seas function will return the model selected for seasonal adjustment. We should next call the final function to get the seasonally adjusted values.\n\nlibrary(seasonal)\npmc_sa_autox13 <- seas(pmc_ts_nsa)\npmc_sa_autox13 %>% \n  final() %>% \n  autoplot() +\n  autolayer(pmc_ts_nsa, series = 'Retail NSA') +\n labs(\n    title = 'Retail sales in Brazil - Volume Index (2014 = 100)',\n    subtitle = 'Seasonally-Adjusted',\n    x = '',\n    y = 'Index (2014 = 100)'\n  )\n\n\n\n\nIt did a good job of getting rid of those peaks in December – and possibly other undesirable hidden stuff. We can use any of those tools we’ve learned in the previous section to check that there’s no seasonality left in the data.\n\npmc_sa_autox13 %>%\n  final() %>% \n  ggmonthplot() +\n  labs(\n    title = 'Retail sales in Brazil - Volume Index (2014 = 100)',\n    subtitle = 'Seasonally-Adjusted',\n    x = '',\n    y = 'Index (2014 = 100)'\n  )\n\n\n\n\nIt looks pretty good! Remember that no seasonal treatment is perfect and the goal is always to have no apparent seasonality in the data. In this case, we could safely make meaningful comparisons between periods. To finish, it’s worth mentioning that we can assess relevant information about the selected model using standard function designed for lm objects. For example, we can assess relevant information on the estimated parameters calling the summary function and check the property of residuals calling the checkresiduals function (or directly perform any test based on model residuals using the residuals function).\n\npmc_sa_autox13 %>% \n  summary()\npmc_sa_autox13 %>% \n  forecast::checkresiduals()\n\n\n\n3.0.3 Moving to a custom specification\nSometimes we just can’t rely on the automatic model selection. Either because we would like to incorporate additional features not available in the function – special moving holidays is a common issue – or because we need to replicate the seasonal adjustment made by third-parties. For instance, IBGE releases its own seasonally-adjusted retail sales data. So if we were to analyze or forecast seasonally-adjusted data using IBGE releases as our target, we would have to invariably adopt its specification.\nLet’s first compare the automatic seasonal adjustment we computed in the previous section with the actual seasonal-adjusted series provided by IBGE.\n\n\nCode\npmc_sa_ibge <- \n  pmc_tidy %>% \n  dplyr::filter(var == 'retail_sa') %>% \n  dplyr::pull(value) %>% \n  ts(start = c(2000,1), frequency = 12)\npmc_sa_autox13 %>% \n  final() %>% \n  autoplot() +\n  autolayer(pmc_sa_ibge, series = 'Retail SA (official)') +\n labs(\n    title = 'Retail sales in Brazil - Volume Index (2014 = 100)',\n    subtitle = 'Seasonally-Adjusted',\n    x = '',\n    y = 'Index (2014 = 100)'\n  )\n\n\n\n\n\nWe can see that for most of the sample our automatic version follows closely the IBGE’s, but it clearly goes off track right after the COVID shock in early 2000’s. Fortunately, IBGE describes the model specification it uses for the seasonal adjustment of this series in a technical note. Some relevant information are: 1. The model specification is SARIMA(0,1,1)(0,1,1); 2. It incorporates Carnival and Corpus Christi – two important moving holidays in Brazil – in the model besides the usual trading days and Easter; and 3. It also includes two level shifts – April 2020 and December 2020 – and a temporary change – April 2020. The latter arguably to cope with the effects of the COVID shock.\nHow can we add these features to the seasonal adjustment model? Starting with the moving holidays, we need to create a vector with the dates of the holidays. However, for some holidays it might be well that their effect may extend beyond the day on which they occur. Carnival is a good example. Even though the holiday happens on a Tuesday, the celebration starts on Monday and ends on Wednesday. Hence, it’s very important to include these two extra days in the input vector. The genhol function makes this task much simpler: it automatically extend our date vector by including a number of earlier and/or later dates defined by the offsetting parameters start and end. Since Carnival and Corpus Christi occur, respectively, 47 and 60 days after Easter we can build the associated vectors from the latter – the seasonal package has built-in dates for Easter inside the easter vector. Otherwise, we would have to build them by ourselves (or import it from somewhere).\nLevel shifts and temporary changes can easily be incorporated using textual shortcuts in the regression.variables parameter. For level shifts we use lsYEAR.MONTH, whereas for transitory changes we use tcYEAR.MONTH. More information on the parameters can be found in the X-13-ARIMA Reference Manual.\nBelow we can see the full specification for the custom model intended to replicate IBGE’s along with the resulting plot.\n\nlibrary(lubridate)\ncarnival         <- easter %m-% days(47)\ncorpus_christi   <- easter %m+% days(60)\ncarnival_holiday <- seasonal::genhol(\n  carnival, \n  start = -1, \n  end = 1, \n  frequency = 12, \n  center = 'calendar'\n)\ncorpus_christi_holiday <- seasonal::genhol(\n  corpus_christi,\n  frequency = 12, \n  center = 'calendar'\n)\npmc_sa_customx13 <- seas(\n  x = pmc_ts_nsa,\n  regression.variables = c(\n    \"td\", \"easter[1]\", \"ls2020.apr\", \"tc2020.apr\", \"ls2020.dec\"\n  ),\n  xreg = ts.union(carnival_holiday, corpus_christi_holiday), \n  regression.usertype = \"holiday\",\n  arima.model = \"(0 1 1)(0 1 1)\", \n  regression.aictest = NULL,\n  outlier = NULL, \n  transform.function = \"log\", \n  x11 = \"\"\n)\npmc_sa_customx13 %>% \n  final() %>% \n  autoplot() +\n  autolayer(pmc_sa_ibge, series = 'Retail SA (official)') +\n  labs(\n    title = 'Retail sales in Brazil - Volume Index (2014 = 100)',\n    subtitle = 'Seasonally-Adjusted',\n    x = '',\n    y = 'Index (2014 = 100)'\n  )\n\n\n\n\nThe new specification produced an almost perfect match with the official seasonally-adjusted data, specially for the post-COVID period. Some deviations are arguably due to slight differences in the holiday vector, but for now we’ll consider the goal achieved."
  },
  {
    "objectID": "ds_nominal2real.html",
    "href": "ds_nominal2real.html",
    "title": "4  Deflating nominal values to real values",
    "section": "",
    "text": "To transform nominal data into real data, two things are needed. First, we have to choose the base (or reference) year. The prevailing prices in that year will be used as a reference for other years. For example, we can transform a sample of the US nominal GDP from 2000 to 2020 using 2010 prices as reference. In this case, all the years in the sample will be denominated in 2010 prices. This is generally an arbitrary choice, but a good practice is to choose a year in which prices have been close to the sample average.\nMore importantly, we need to choose an appropriate price index to use as the deflator. The ideal deflator should be the one that best measures the change in prices of the basket of goods or services represented by the series we want to adjust. For instance, it would make no sense to deflate a series of retail sales by a construction price index. In the absence of a specific price index for the basket of goods considered in the retail sales series, we could use a more general consumer price index as a proxy.\nLet’s see a practical example of how to deflate a series. For this, we will use data on nominal GDP for the United States provided by the Bureau of Economic Analysis (BEA). It’s also a good opportunity to introduce how to access data from this relevant source using its APÌ service.\nYou’ll need to register in order to receive access to the API. This procedure takes a few minutes and requires little information. Since this information is personal, I stored my key as an environmental variable.\nBEA provides a detailed document explaining how to use the API resources. Below, I’ll first retrieve the table names from the NIPA data base, where GDP data are stored. Note that I use the pluck function from the purrr package as a substitute for [[.1 This makes it easier to access the lower-level elements of lists.\n\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(jsonlite)\napi_bea_key <- Sys.getenv('api_bea_key')\nbea_nipa_tables <- GET(\n  glue::glue(\n    'https://apps.bea.gov/api/data?UserID={api_bea_key}&method=GetParameterValues&datasetname=NIPA&ParameterName=tablename&ResultFormat=JSON'\n  )\n) %>% \n  content(as = 'text') %>% \n  fromJSON() %>% \n  pluck(1,2,1)\n\nWe can see that the two tables of interest are T10105 (Gross Domestic Product) and T10104 (Price Indexes for Gross Domestic Product). Given that the import procedure is the same for both series, it makes sense to create a function with the necessary steps and then use map to apply it to each table name.\n\nbea_tables <- list(\n  'Nominal GDP' = 'T10105',\n  'Deflator'    = 'T10104'\n)\nget_bea_data <- function(tablename, api_bea_key){\n  api_bea_request <- glue::glue(\n    'https://apps.bea.gov/api/data?UserID={api_bea_key}&method=GetData&DataSetName=NIPA&TableName={tablename}&Frequency=A&Year=ALL&ResultFormat=json'\n  )\n  gdp_request <- GET(url = api_bea_request)\n  gdp_content <- content(gdp_request, as = 'text')\n  gdp_list    <- fromJSON(gdp_content, flatten = FALSE)\n  gdp_tbl     <- pluck(gdp_list, 1, 2, 4) \n}\nbea_data <- map(\n  .x = bea_tables,\n  .f = ~ get_bea_data(.x, api_bea_key)\n)\n\nNext, I arrange the data in tidy format to facilitate future calculations.\n\nbea_data_tbl <- map(\n  .x = bea_data,\n  .f = ~ .x %>% \n    filter(LineDescription == 'Gross domestic product') %>% \n    select(TimePeriod, DataValue)\n) %>% \n  plyr::ldply(.id = 'Serie') %>% \n  pivot_wider(names_from = Serie, values_from = DataValue) %>% \n  mutate(across(c(`Nominal GDP`), ~ str_remove_all(.x, ','))) %>% \n  mutate(across(-TimePeriod, ~ .x %>% as.numeric())) %>% \n  arrange(TimePeriod)\nbea_data_tbl\n\n# A tibble: 94 x 3\n   TimePeriod `Nominal GDP` Deflator\n   <chr>              <dbl>    <dbl>\n 1 1929              104556     9.39\n 2 1930               92160     9.03\n 3 1931               77391     8.14\n 4 1932               59522     7.21\n 5 1933               57154     7.01\n 6 1934               66800     7.36\n 7 1935               74241     7.50\n 8 1936               84830     7.60\n 9 1937               93003     7.87\n10 1938               87352     7.73\n# ... with 84 more rows\n\n\nNow we are ready to convert nominal GDP into real GDP. For this, all we have to do is to pick an arbitrary year as reference, say 2005, and divide the whole price index series by its value in 2005. This means that the price index in 2005 is equal to 1 and other values are in proportion to it. Finally, we divide the nominal GDP series by this new price index series.\n\ngdp_real <- bea_data_tbl %>% \n  mutate(\n    Deflator_2005 = (Deflator/Deflator[which(TimePeriod == 2005)]),\n    `Real GDP`    = `Nominal GDP`/Deflator_2005\n    )\n\n\n\nShow the code\nlibrary(lubridate)\ngdp_real %>% \n  pivot_longer(-TimePeriod, names_to = 'var', values_to = 'value') %>% \n  filter(str_detect(var, 'Deflator', negate = TRUE)) %>% \n  mutate(TimePeriod = as_date(TimePeriod, format = '%Y')) %>% \n  ggplot(aes(x = TimePeriod)) +\n  geom_line(aes(y = value, color = var), lwd = 1) +\n  scale_y_continuous(labels = scales::dollar_format(scale = 1/1e6, prefix = \"$\", suffix = \"T\")) +\n  scale_x_date(date_breaks = '20 years', date_labels = '%Y') +\n  theme(legend.position = 'top') +\n  labs(\n    title = 'US Annual GDP: Nominal vs. Real (2005 Dollars)',\n    y = '',\n    x = '',\n    color = ''\n  )\n\n\n\n\n\nIt’s clear that ignoring price changes leads to a gross misinterpretation of the GDP growth trajectory. This is precisely the kind of thing we want to avoid when adjusting the series for inflation.\n\n\n\n\n\npluck(.x, 1,2,1) is equivalent to .x[[1]][[2]][[1]]↩︎"
  },
  {
    "objectID": "ds_hpfilter.html",
    "href": "ds_hpfilter.html",
    "title": "5  Hodrick-Prescott Filter",
    "section": "",
    "text": "There are several statistical filters that perform this task, the best known being the Hodrick-Prescott filter. The HP-Filter requires only a single parameter, \\(\\lambda\\), which controls the sensitivity of the trend to short-term fluctuations. The rule of thumb is to use \\(\\lambda = 1600\\) for quarterly data; \\(\\lambda = 14400\\) for monthly data; and \\(\\lambda = 100\\) for yearly data. The hpfilter function from the mFilter implements the HP-Filter with default values for \\(\\lambda\\) defined by the frequency of the time series object ts.\nTo see how it works in practice, let’s import data on Brazilian GDP using the sidrar package which is an interface to IBGE’s API. I choose to define the date variable using the as.yearqtr function from the zoo package because it’s compatible with ts objects – which is the default input for the hpfilter function.\n\nlibrary(tidyverse)\nlibrary(lubridate)\ngdp_br <- sidrar::get_sidra(api = '/t/1620/n1/all/v/all/p/all/c11255/90707/d/v583%202')\ngdp_br <- gdp_br %>% \n  select(quarter = `Trimestre (Código)`, gdp = Valor) %>% \n  mutate(quarter = zoo::as.yearqtr(quarter, format = '%Y%q'))\ngdp_br_ts <- ts(gdp_br$gdp, start = first(gdp_br$quarter), frequency = 4)\n\n\n\nShow the code\nlibrary(forecast)\ngdp_br_ts %>%\n  autoplot() +\n  labs(\n    title = 'Brazilian Quarterly GDP (Index: 1995 = 100)',\n    x = '',\n    y = 'Brazilian Quarterly GDP (Index: 1995 = 100)'\n  )\n\n\n\n\n\nSince the HP-Filter is not explicitly designed to deal with seasonality, I first remove the seasonal component using the automatic selection model provided by the seas function (see (seasonality?)). The remaining pieces of code just apply the HP-Filter to the GDP time series and arrange the relevant output into a data frame.\n\nlibrary(seasonal)\nlibrary(mFilter)\ngdp_br_sa <- final(seas(gdp_br_ts))\ngdp_br_hp <- hpfilter(gdp_br_sa)\nhp_out    <- tibble(\n  'quarter' = gdp_br$quarter,\n  'cycle'   = gdp_br_hp$cycle %>% c(),\n  'trend'   = gdp_br_hp$trend %>% c()\n)\n\n\n\nShow the code\nhp_out %>% \n  pivot_longer(-quarter, 'var', 'value') %>% \n  ggplot(aes(x = quarter)) +\n  geom_line(aes(y = value), lwd = 1) +\n  facet_wrap(~ var, scales = 'free_y', ncol = 1) +\n  labs(\n    title = 'HP-Filter decomposition of Brazilian GDP',\n    x = '', \n    y = ''\n    )\n\n\n\n\n\nDespite its vast popularity and widespread use, the HP filter gets mixed reviews. Perhaps the best known of these is the end-point bias, whose most common workaround is to add projections to the end of the series before applying the filter. We won’t dive into the pros and cons of the HP filter, since it’s beyond the scope of this book. Hamilton (2017) formalized several of these issues and proposed a new filter that was supposed to overcome all of them. According to the author:\n\n“A regression of the variable at date \\(t+h\\) on the four most recent values as of date t offers a robust approach to detrending that achieves all the objectives sought by users of the HP filter with none of its drawbacks.”\n\nThe fitted values and the residuals from the equation below provide, respectively, the trend and cycle components of the Hamilton filter. As a practical guide, Hamilton suggested using \\(h=8\\) for quarterly data. Nonetheless, some series may require longer periods \\(h\\) or more lags \\(k\\) for the filter to be effective.\n\\[ y_{t+h} = \\alpha + \\sum_{p=1}^{4} \\beta_p y_{t+1-p} \\]\nWe can perform Hamilton’s filter by estimating the above equation and then arranging the corresponding output into a data frame as we did with the HP filter. The augment function from the broom package does a great job in converting the output in the lm object into a data frame.\n\ngdp_br_hamilton <- tibble(\n  quarter = gdp_br$quarter,\n  gdp_sa  = gdp_br_sa %>% c()\n) %>% \n  mutate(\n    y   = gdp_sa,\n    y1  = lag(gdp_sa, 8),\n    y2  = lag(gdp_sa, 9),\n    y3  = lag(gdp_sa, 10),\n    y4  = lag(gdp_sa, 11)\n  ) \nhamilton_filter <- lm(y ~ y1 + y2 + y3 + y4, gdp_br_hamilton)\nhamilton_out <- hamilton_filter %>% \n  broom::augment() %>% \n  mutate(quarter = gdp_br_hamilton$quarter[as.numeric(.rownames)]) %>% \n  select(quarter, trend = .fitted, cycle = .resid)\n\n\n\nShow code\nhamilton_out %>% \n  pivot_longer(-quarter, 'var', 'value') %>% \n  ggplot(aes(x = quarter)) +\n  geom_line(aes(y = value), lwd = 1) +\n  facet_wrap(~ var, scales = 'free_y', ncol = 1) +\n  labs(\n    title = 'Hamilton-Filter decomposition of Brazilian GDP',\n    subtitle = 'h = 8',\n    x = '', \n    y = ''\n    )\n\n\n\n\n\nWe can see a sharp drop-and-rise in the final part of the output series which is at odds with what we would expect from a trend component. This problem can be solved by setting \\(h = 12\\) (\\(h\\) should be a multiple of the time series frequency). The new plot is shown below.\n\n\nShow code\ngdp_br_hamilton2 <- tibble(\n  quarter = gdp_br$quarter,\n  gdp_sa  = gdp_br_sa %>% c()\n) %>% \n  mutate(\n    y   = gdp_sa,\n    y1  = lag(gdp_sa, 12),\n    y2  = lag(gdp_sa, 13),\n    y3  = lag(gdp_sa, 14),\n    y4  = lag(gdp_sa, 15)\n  ) \nhamilton_filter2 <- lm(y ~ y1 + y2 + y3 + y4, gdp_br_hamilton2)\nhamilton_out2 <- hamilton_filter2 %>% \n  broom::augment() %>% \n  mutate(quarter = gdp_br_hamilton2$quarter[as.numeric(.rownames)]) %>% \n  select(quarter, trend = .fitted, cycle = .resid)\nhamilton_out2 %>% \n  pivot_longer(-quarter, 'var', 'value') %>% \n  ggplot(aes(x = quarter)) +\n  geom_line(aes(y = value), lwd = 1) +\n  facet_wrap(~ var, scales = 'free_y', ncol = 1) +\n  labs(\n    title = 'Hamilton-Filter decomposition of Brazilian GDP',\n    subtitle = 'h = 12',\n    x = '', \n    y = ''\n    )\n\n\n\n\n\n\n\nShow code\nfinal_out <- hamilton_out2 %>% \n  mutate(type = 'Hamilton') %>% \n  bind_rows(\n    hp_out %>% \n      mutate(type = 'HP')\n  )\nfinal_out %>% \n  pivot_longer(-c(quarter, type), 'var', 'value') %>% \n  ggplot(aes(x = quarter)) +\n  geom_line(aes(y = value, color = type), lwd = 1) +\n  facet_wrap(~ var, scales = 'free_y', ncol = 1) +\n  theme(legend.position = 'top') +\n  labs(\n    title = 'Trend-Cycle Decomposition of Brazilian GDP',\n    x = '', \n    y = '',\n    color = ''\n  )\n\n\n\n\n\nWhich one should we choose in this case? From the statistical point of view, the HP Filter yielded a smoother path for the trend component and a desired stationary behavior for the cycle component. Nevertheless, theory suggests that there’s a link between the cycle component of the GDP and inflation. Thus, a common strategy is to evaluate what measure would have explained (core) inflation better in that period. Alternatively, other developments in the economy could favor the choice of either measure. Therefore, it would be up to the analyst to choose which one would best represent his view of the evolution of the economy in that period."
  },
  {
    "objectID": "fc_abc.html",
    "href": "fc_abc.html",
    "title": "6  The ABC",
    "section": "",
    "text": "In recent years, forecasting has been widely associated with sophisticated Machine (or Deep) Learning methods such as XGBoost, LSTM, Random Forest and Neural Networks. In fact, these algorithms have proven to be very effective in improving forecast accuracy in various contexts. However, in most day-to-day applications simpler statistical methods deliver a fairly good result at a very low cost of implementation. Also, they can serve as a good benchmark for more complex models.\nIn this Chapter we’ll cover the basic steps to generate forecasts of a time series, making extensive use of the resources from the forecast package to predict the Brazilian CPI ex-regulated prices. I’d like to draw your attention to the fact that the choice of the appropriate method, though very relevant, is only part of the process. Therefore, in order to be successful we’ll need to understand and treat every single step very carefully.\nFor those interested in a more rigorous and detailed approach to this subject, I couldn’t recommend enough the exceptional Hyndman and Athanasopoulos (2018)."
  },
  {
    "objectID": "fc_abc.html#step-1-observe-the-time-series-features",
    "href": "fc_abc.html#step-1-observe-the-time-series-features",
    "title": "6  The ABC",
    "section": "6.1 Step 1: Observe the time series features",
    "text": "6.1 Step 1: Observe the time series features\nForecasting is all about extrapolating patterns. When our forecast depends on other variables, we’re assuming that the historical relationship between the target and the explanatory variables holds into the future. Likewise, when we’re employing univariate methods the main assumption is that the time series features remain constant or evolve in an understandable way. Hence, the first step is to investigate the features of the time series.\nLet’s import the monthly CPI ex-regulated prices (Not Seasonally Adjusted) from the Brazilian Central Bank API using the rbcb package. Then, we’ll plot the series with the autoplot function from the forecast package. Note that it’s based on ggplot so we can add ggplot resources to the plot.\n\nlibrary(forecast)\nlibrary(tidyverse)\ncpi_br <- \n  rbcb::get_series(\n    code = list(\"cpi\" = 11428),\n    start_date = \"2004-01-01\",\n    end_date   = \"2022-08-01\",\n    as = \"ts\")\n\n\nautoplot(cpi_br) + \n  labs(\n    title = 'Brazilian CPI ex-regulated prices - %MoM NSA',\n    y = '',\n    x = ''\n    ) +\n  scale_y_continuous(labels = function(x) paste0(x, '%'))\n\n\n\n\nFigure 6.1: Plot of Brazilian CPI ex-regulated prices - %MoM NSA\n\n\n\n\nFigure 6.1 gives a general picture of the time series. We can visually infer that the average CPI was around 0.5% from 2004 to 2016, then dropped to half that from mid-2016 to early 2020 before the Covid-19 pandemic hit the economy. This episode started a trend where inflation increased to values close to 1%.\nA more useful plot can be obtained using the mstl function, which decomposes the series into trend, seasonal and remainder (noise) terms. These are precisely the features we’re most interested in understanding in order to make accurate predictions.\n\nmstl(cpi_br) %>% \n  autoplot() +\n  labs(title = 'Brazilian CPI: time series decomposition')\n\n\n\n\nFigure 6.2: MSTL Decomposition of the Brazilian CPI ex-regulated prices time series\n\n\n\n\nWe can extract two important pieces of information from Figure 6.2. The first one is that the trend started in the aftermath of the Covid-19 pandemic is flattening, although with no clear sign of a reversion; and the second one is a noticeable change in the seasonal pattern as of 2016, with higher peaks and a different shape. So when selecting an appropriate forecasting model we should opt for those with a flexible approach to both trend and seasonality, in the case of univariate models, or choose explanatory variables which reproduce this pattern at some extent."
  },
  {
    "objectID": "fc_abc.html#step-2-split-the-sample",
    "href": "fc_abc.html#step-2-split-the-sample",
    "title": "6  The ABC",
    "section": "6.2 Step 2: Split the sample",
    "text": "6.2 Step 2: Split the sample\nWe need to split the sample into training and testing sets in order to perform the evaluation of our model. There are several splitting schemes and the choice depends on the nature of the data and the sample size. For time series, the most robust scheme is block cross-validation, where many contiguous sections of the time series are selected at random to train the model and tests are performed on the adjacent observations. In practice, however, it’s very common to use the leave-one-out approach, where we train the model using observations up to \\(t-1\\) to predict the target at \\(t\\). This procedure is iterated over \\(t\\) in order to provide a representative set of (pseudo) out-of-sample forecasts that we can use to assess the model accuracy.\nNote that the structural changes we saw in Figure 6.2 have important implications on the choice of the split scheme. More specifically, the new seasonal pattern comprises about 40% of the sample, whereas the post-Covid trend is present in only 15%. Thus, testing our model over the whole sample – or a sample which overrepresents this period – could make us believe that we have a good model to predict the future when in fact we don’t.\nLet’s make a simple though very common choice here: take the sample as of 2016 and use the leave-one-out approach starting at Jan/2019 to predict the twelve months ahead. We’ll use the rsample package which is part of the tidymodels ecosystem of R packages specially designed to handle forecasting in a tidy way. Since it’s under the tidy philosophy, we need to first convert our data from ts to data frame or tibble. It can be easily achieved using the timetk package.\nThe rolling_origin function from rsample provides a convenient object where in each slice we have two components, the train set and the test set, which can be accessed by specific functions. The initial argument defines the size of the initial sample used for training the model; the assess argument defines the number of observations used for assessment in each step; and cumulative = TRUE means we’ll not drop the first value of the sample as we incorporate a new value so as to keep the sample size constant. Rather, we’ll have an expanding-window sample.\n\nlibrary(rsample)\nlibrary(timetk)\ncpi_df <- \n  tk_tbl(cpi_br, rename_index = 'date') %>% \n  filter(date >= 'jan 2016')\ncpi_split <- \n  rolling_origin(\n  cpi_df, \n  initial = which(cpi_df$date == 'dec 2018'),\n  assess = 1,\n  cumulative = TRUE\n  ) \ncpi_split\n\n# Rolling origin forecast resampling \n# A tibble: 44 x 2\n   splits         id     \n   <list>         <chr>  \n 1 <split [36/1]> Slice01\n 2 <split [37/1]> Slice02\n 3 <split [38/1]> Slice03\n 4 <split [39/1]> Slice04\n 5 <split [40/1]> Slice05\n 6 <split [41/1]> Slice06\n 7 <split [42/1]> Slice07\n 8 <split [43/1]> Slice08\n 9 <split [44/1]> Slice09\n10 <split [45/1]> Slice10\n# ... with 34 more rows\n\n\nAs you can see, the cpi_split contains 43 slices – each slice is represented by a two-dimensional sample with [train set/test set]. The first slice contains a training set ranging from Jan/2016 to Dec/2018 (36 observations) and a test set with a single observation on Jan/2019. The second slice incorporates the observation on Jan/2019 to the training set (37 observations now) and leaves Feb/2019 as the test set. The same logic applies to the other slices until the end of the sample. With our split scheme done, we’re ready to go the next step."
  },
  {
    "objectID": "fc_abc.html#step-3-choose-the-model",
    "href": "fc_abc.html#step-3-choose-the-model",
    "title": "6  The ABC",
    "section": "6.3 Step 3: Choose the model",
    "text": "6.3 Step 3: Choose the model\nChoosing an appropriate model involves several dimensions. First, we should decide whether or not to use explanatory variables – and if so, which variables to use. In addition, we should weigh the pros and cons of employing a machine learning model instead of a simpler method. Considerations on both time and interpretability play a significant role in many fields. Since the purpose here is to develop intuition about each step of the forecasting pipeline, I’ll avoid these issues by assuming we’re restricted to using univariate statistical models only. This is by no means a very strong assumption since in real-life we are often required to provide reasonable forecasts quickly rather than spending a great amount of time searching for the most accurate numbers.\nThe forecast package contains a large set of very useful univariate statistical models. The ETS is generally my choice when I have no obvious candidate, because it doesn’t impose any strong assumption about the data (eg. stationarity). In addition, it has proven to perform very well on a variety of data sets at the M Competition. I use TBATS as a first approach whenever I have to predict high frequency data (daily or higher) since it can handle multiple seasonal patterns. ARIMA is useful for stationary data, specially when ACF/PACF plots show a well-defined autocorrelation structure. However, it’s worth noting that in practice statistical assumptions are often overlooked when the purpose of the model is forecasting rather than making inference.\nAs a matter of fact, producing accurate forecasts is inevitably a trial and error process and, as we become experienced with the subject, some choices look more promising. For instance, we saw that the Brazilian CPI exhibit a changing trend – favoring a more flexible model like ETS. On the other hand, for most of the period this trend seems to evolve at a constant pace, which makes ARIMA models good candidates as well. In addition, in the presence of a seasonal pattern models which are more successful in capturing the seasonality of the data have a clear advantage. It’s not unusual for one model to be better at capturing a specific feature of the data while another model does the same for other feature – that’s why combining the forecasts from different models usually improve accuracy.1 Therefore, in order to have a more reliable result we’ll produce forecasts from three sources: ETS, ARIMA and the average between them.\n\ncpi_fc <- cpi_split %>% \n  mutate(\n    ets_fc = map_dbl(\n      .x = splits, \n      .f = ~ (.x %>% \n        analysis() %>% \n        tk_ts(select = 'value', start = c(2016,1), frequency = 12) %>% \n        ets() %>% \n        forecast(h = 1)\n        )$mean\n      ),\n    arima_fc = map_dbl(\n      .x = splits, \n      .f = ~ (.x %>% \n        analysis() %>% \n        tk_ts(select = 'value', start = c(2016,1), frequency = 12) %>% \n        auto.arima() %>% \n        forecast(h = 1)\n        )$mean\n    ),\n    avg_fc = (arima_fc+ets_fc)/2,\n    date = map_chr(\n      .x = splits,\n      .f = ~ (.x %>% \n                assessment()\n              )$date %>% \n        as.character()\n    )  %>% \n        zoo::as.yearmon()\n    ) %>% \n  select(date, contains('fc')) %>% \n  right_join(cpi_df, by = 'date')\ncpi_fc\n\n# A tibble: 80 x 5\n   date      ets_fc arima_fc avg_fc value\n   <yearmon>  <dbl>    <dbl>  <dbl> <dbl>\n 1 Jan 2019   0.166   0.330  0.248   0.41\n 2 Feb 2019   0.179   0.364  0.271   0.48\n 3 Mar 2019   0.285   0.414  0.349   0.75\n 4 Apr 2019   0.416   0.567  0.492   0.41\n 5 May 2019   0.444   0.377  0.411  -0.23\n 6 Jun 2019   0.368   0.200  0.284   0.08\n 7 Jul 2019   0.236   0.142  0.189   0.12\n 8 Aug 2019   0.187   0.132  0.160  -0.06\n 9 Sep 2019   0.187   0.0449 0.116  -0.1 \n10 Oct 2019   0.126  -0.0230 0.0516  0.18\n# ... with 70 more rows\n\n\nNow we have a data frame with the predictions from each source plus the actual (realized) value for the CPI for the last 45 months – including periods pre-, during- and post-Covid. In the next section, we’ll see how to get a representative summary of the results so as we can conclude which model is better. You may have a clue on how to do this, but I can assure you that there are some relevant aspects worth exploring that are hardly found elsewhere. Before moving to the next section, we can take a look on how these forecasts look like.\n\n\nShow the code\ncpi_fc %>% \n  pivot_longer(-date, names_to = 'model', values_to = 'forecast') %>% \n  ggplot(aes(x = date)) +\n  geom_line(aes(y = forecast, color = model), lwd = 1) +\n  theme_light() +\n  scale_color_brewer(type = 'qual', palette = 6) +\n  theme(legend.position = 'top') +\n  labs(title = 'Brazilian CPI Forecasts - %MoM NSA',\n       y = 'CPI (%MoM NSA)',\n       color = '')\n\n\nWarning: Removed 108 row(s) containing missing values (geom_path)."
  },
  {
    "objectID": "fc_abc.html#step-4-evaluate-the-model",
    "href": "fc_abc.html#step-4-evaluate-the-model",
    "title": "6  The ABC",
    "section": "6.4 Step 4: Evaluate the model",
    "text": "6.4 Step 4: Evaluate the model\nChoosing the best forecasting model can be stated in mathematical terms as a problem of minimizing an error metric – the mean absolute error (MAE) or the root mean square error (RMSE) being common choices. These metrics are loss functions, i.e, they express an objective. Consequently, we should be fully aware of what our objective is in order to translate it into an appropriate metric (or function).\nFor example, MAE and RMSE are symmetric functions and use simple average to summarize the forecasting errors. Using both of them to evaluate model’s accuracy is equivalent to say: “I don’t care about the sign of the error – 2 units up or down equally impact my result; Also, it doesn’t matter when the largest errors occurred – over the last 3 observations or in the early part of the evaluation period”.\nSurely, these conditions don’t apply to all businesses. Someone interested in forecasting the demand for electricity in a large city might prefer to be surprised down than up. Also, a model with higher accuracy in the last 12 months might be better at capturing the current electricity demand pattern than a model with a great performance on the initial periods of the testing sample. In short, many situations require us to define what conditions the model must meet and this involves designing a specific function. This function should summarize the forecast errors in order to represent our objective.\nTo demonstrate this idea, I will propose two alternative accuracy metrics that are slight modifications of the well-known MAE. The first (accuracy_1) assigns double the weight to upside errors (predictions below actual values), whereas the second (accuracy_2) assigns (linearly) decreasing weights as further in the past the errors are. You should be aware that the results from the two metrics are not directly comparable, the ordering of models being the relevant information here.\n\naccuracy_1 <- function(e){\n  .abs_weighted_errors      <- ifelse(e > 0, 2*e, abs(e))\n  .mean_abs_weighted_errors <- mean(.abs_weighted_errors)\n  return(.mean_abs_weighted_errors)\n}\naccuracy_2 <- function(e){\n  .abs_errors               <- abs(e)\n  .weights                  <- seq(from = 1, to = length(.abs_errors), by = 1)\n  .weights                  <- .weights/sum(.weights)\n  .mean_abs_weighted_errors <- weighted.mean(.abs_errors, .weights)\n  return(.mean_abs_weighted_errors)\n}\n\nBelow I plot the accuracy_1 function along with the original MAE function as a more effective way to give you a sense of what’s happening behind the scenes. Basically, for negative errors (realized value below the prediction) the weigh are the same as in the original MAE, while it’s somewhat higher for positive errors (realized value above the prediction).\n\n\nShow the code\nlibrary(ggtext)\nacc_demo <- tibble(\n  x = seq(from = -2, to = 2, by = 0.01)\n) %>% \n  mutate(\n    t   = 1:n(),\n    Loss_1 = ifelse(x > 0, 2*x, abs(x)),\n    mae    = abs(x)\n  )\nacc_demo %>% \nggplot(aes(x = x)) + \n  geom_line(aes(y = Loss_1), color = \"darkblue\", lwd = 1) +\n  geom_line(aes(y = mae), color = \"red\", lwd = 1) +\n  geom_vline(xintercept = 0, linetype = \"dashed\") +\n  theme_light() +\n  theme(plot.title = element_markdown(lineheight = 1.1),\n        axis.title = element_text(size = 13),\n        legend.position = \"none\") +\n  labs(title = \"<span style='color:#002266;'><b>Custom Loss Function</b></span> vs <span style='color:#ff1a1a;'><b>MAE</b></span>\",\n       x = \"Error\", y = \"Loss\")\n\n\n\n\n\nNow we’re ready to apply our two custom functions plus the MAE to the errors we computed from the three models in order to decide which one is the most accurate. Again, these metrics aren’t comparable to each other. Instead, we’re interested in the ordering within the same metric. In addition, there’s no such a thing as the best metric. As we saw earlier in this section, the appropriate metric is the one that reflects as closely as possible our objective. Besides, we find several desirable characteristics in conventional metrics such as MAE or RMSE and I don’t mean to rule them out. The main message here is that we must be fully aware of what our objective is and how to translate it into an appropriate function. In this regard, the knowledge of functional forms is essential.\n\ncpi_errors <- cpi_fc %>% \n  filter(date >= 'Jan 2019') %>% \n  mutate(across(contains('fc'), ~ value - .x, .names = 'error_{.col}')) %>% \n  summarise(\n    across(contains('error'), \n           list(\n             'acc1' = ~ accuracy_1(.x), \n             'acc2' = ~ accuracy_2(.x),\n             'mae'  = ~ mean(abs(.x))\n           ), \n           .names = '{.col}-{.fn}')) %>% \n  pivot_longer(everything(), names_to = 'model_metric', values_to = 'value') %>% \n  separate('model_metric', c('model', 'metric'), '-') %>% \n  pivot_wider(names_from = 'metric', values_from = 'value') %>% \n  mutate(model = str_remove_all(model, 'error_|_fc'))\ncpi_errors\n\n# A tibble: 3 x 4\n  model  acc1  acc2   mae\n  <chr> <dbl> <dbl> <dbl>\n1 ets   0.488 0.304 0.317\n2 arima 0.456 0.286 0.284\n3 avg   0.468 0.292 0.298\n\n\nThe results show that the ARIMA model is the most accurate by the three metrics, outperforming even the average model. At this point, I’d like to conclude with two considerations. The first is that combining models usually improves performance, but not always as the above exercise made clear. Nevertheless, although the literature shows that using either the mean or median of the models is very difficult be beaten, it’s possible to improve accuracy by optimizing the weights assigned to each model. Finally, we compared the models by means of their point forecasts. Despite being very common, this does not take into account the fact that each point forecast is one single realization of a random process and there is a vast literature that suggests the use of density forecasts and distributional accuracy measures.\n\n\n\n\nHyndman, R. J., and G. Athanasopoulos. 2018. Forecasting: Principles and Practice, 2nd Edition. OTexts: Melbourne, Australia."
  },
  {
    "objectID": "fc_comparison.html",
    "href": "fc_comparison.html",
    "title": "7  Forecasting by comparison",
    "section": "",
    "text": "Forecasting is correctly understood as a task of extrapolating historical patterns of a given process in order to infer a plausible range where future values should lie. Sometimes, however, we don’t have a historical pattern to rely on. Think of the onset of COVID-19 outbreak in 2020, for example. This event was completely new and, except for some ideas borrowed from the epidemiology literature, we didn’t know much about how the virus would spread nor did we have enough data to perform a minimally robust analysis.\nIn this section, we’ll discuss a widely used technique to predict variables for which we have no direct data: comparison. The basic idea is that we should look for a similar event somewhere else, either currently going on or in the past, and then assume that our variable of interest will follow closely that pattern. The most important (and difficult) thing here is to choose reasonable units for comparison. Ultimately, this is what guarantees the validity of the exercise. We’ll walk through two examples which show that a mix of creativity and statistical concepts can deliver decent answers to complicated questions."
  },
  {
    "objectID": "fc_comparison.html#the-early-days-of-covid-19-in-brazil",
    "href": "fc_comparison.html#the-early-days-of-covid-19-in-brazil",
    "title": "7  Forecasting by comparison",
    "section": "7.1 The early days of COVID-19 in Brazil",
    "text": "7.1 The early days of COVID-19 in Brazil\nIt was the beginning of March, 2020 and we were seeing new cases of COVID spreading rapidly in different countries in Asia and Europe. In Brazil, it would start a few weeks later. At that time I was working at Itau Asset Management, a well-known hedge fund in Brazil. Portfolio managers and analysts needed an accurate yet timely sense of how the situation would evolve domestically in order to make reasoned decisions and keep track of the potential impact on both economic and financial variables. However, Brazil was then stepping into the early days of the epidemic curve so that no more than a handful of observations were available to estimate any model. How could I deliver a reliable answer?\nI started looking for patterns stemming from other countries which were already a couple of weeks ahead in this process. This search brought about some interesting clues. In particular, I noticed that for several countries the daily increase in cumulative cases was very noisy up to the hundredth confirmed case, but then it seemed to decrease slowly – though not steadily – as a function of time. We can check it in the plot below.\n\n\nShow the code\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(openxlsx)\ncovid_data <- readRDS('data/ch07_covid_data.rds')\ncovid_data_aux <- covid_data %>%\n  filter(type == \"confirmed\") %>%\n  group_by(Country.Region) %>%\n  mutate(\n    acum_cases = cumsum(cases),\n    r = ((acum_cases/lag(acum_cases))-1)*100\n    ) %>%\n  filter(acum_cases >= 100) %>%\n  mutate(t = 1:n()) %>%\n  ungroup()\n\n\n\n\nShow the code\nlibrary(gghighlight)\nlibrary(ggrepel)\ncountries_out <- c(\"Qatar\", \"Pakistan\", \"Dominican_Republic\")\ncovid_data_aux %>%\n  dplyr::filter(\n    !Country.Region %in% countries_out,\n    t <= 50,\n    date <= '2020-03-17'\n  ) %>%\n  ggplot(aes(x = t, y = r, color = Country.Region)) +\n  geom_line(lwd = 1) +\n  gghighlight(Country.Region %in% c(\"Brazil\", \"Italy\", \"Iran\")) +\n  theme_light() +\n  scale_y_continuous(labels = function(x) paste0(x, \"%\")) +\n  theme(legend.position = \"none\") +\n  labs(\n    title = \"Daily increase in total cases for available countries (%)\",\n    subtitle = 'Data up to 2020-03-17',\n    x = \"Days after 100th confirmed case\",\n    y = \"\", \n    color = \"\",\n    caption = \"Data: European Centre for Disease Prevention and Control.\"\n    )\n\n\n\n\n\nI could explore this fact to obtain future values for Brazil. Of course that reasoning assumed that the daily increase in total cases for Brazil would on average resemble the path of a given country or a pool of countries (if I used a panel regression) – not a very strong assumption, especially if we consider the lack of data.\nIn this regard, I decided to rule out countries which did not appear to be reasonable benchmarks such as China and South Korea since they had imposed tight restrictions very quickly – and I didn’t expect Brazil to do the same. Two countries were seemingly good candidates back then, Iran and Italy. Both of them shared the time pattern described above. Furthermore, expectations were that tougher restrictions would be implemented only progressively – something I suspected would be done in Brazil too.\nSo how did I make use of the information from these countries to produce forecasts for Brazil? Firstly, I estimated the curve above using a simple OLS regression with data as of the hundredth case – the period where the time trend was noticeable. I chose to model each country separately since I could assess each path later and eventually discard the one performing worse.\nLet \\(r_t\\) be the daily increase in total cases in period \\(t\\) and \\(i = [\\text{Italy, Iran}]\\). Then,\n\\[ log(r_{it}) = \\beta_0 + \\beta_1t_i \\hspace{0.5cm} (1)\\] The OLS estimate for this equation is shown below.\n## Data for regression\ndata_reg <- covid_data_aux %>%\n  dplyr::filter(\n    Country.Region %in% c(\"Italy\", \"Iran\")\n  ) %>%\n  plyr::dlply(.variables = \"Country.Region\")\n## Model equation\nmod_eq <- 'log(r) ~ t' %>% as.formula()\n## Fit the model\nfit_reg <- map(.x = data_reg, .f = ~ lm(mod_eq, data = .x))\n\n\nShow the code\nlibrary(jtools)\n## Plot model results\nexport_summs(\n  fit_reg$Italy, \n  fit_reg$Iran,\n  model.names = rev(names(fit_reg))\n)\n\n\n\n\n\nItalyIran\n\n(Intercept)4.05 ***3.79 ***\n\n(0.07)   (0.11)   \n\nt-0.06 ***-0.06 ***\n\n(0.00)   (0.00)   \n\nN55       52       \n\nR20.95    0.86    \n\n *** p < 0.001;  ** p < 0.01;  * p < 0.05.\n\n\n\n\nNext, consider \\(C_t\\) the number of total cases in period \\(t\\). Thus the total cases in Brazil for \\(t+1\\) is given by:\n\\[ C_{t+1} = C_t \\times \\left(1+\\frac{\\hat{r_{it}}}{100}\\right) \\ (2)\\] where \\(\\hat{r_{it}} = e^{\\hat{\\beta^0} + \\hat{\\beta_1}t_i}\\)\nHence the path computed in \\(t\\) for \\(t+k\\), \\(k = 1,2,3,4, ... ,T\\) is given by:\n\\[ C_{t+k} = C_t \\times \\prod_{t}^{k}\\left(1+\\frac{\\hat{r_{it}}}{100}\\right) \\ (3)\\] Note that we can use the fitted values from Equation 1 to obtain \\(\\hat{r_{it}}\\) as long as \\(t+k\\) is available in the sample of the country \\(i\\). For a longer period not yet reached by the country \\(i\\), we could easily make forecasts of \\(\\hat{r_{it}}\\) since the only co-variate is \\(t\\) – the time in days after the hundredth confirmed case.\nLet us suppose we are on March 16 (the third day after Brazil exceeded 100 cases) and we wish to compute the path for the next three days. Thus we need \\(\\hat{r}_{it}\\) for \\(t =\\) 4, 5 and 6 as well as \\(C_3 = 235\\), the number of total cases recorded in March 16. We dubbed Iran-like and Italy-like the forecasts for Brazil based on the fitted values using data from these countries.\nFor example, to produce the Italy-like path on March 16 we should first take the (exponentiated) fitted values from the Italy model.\n\n1+exp(fitted(fit_reg$Italy))/100\n\n       1        2        3        4        5        6        7        8 \n1.536947 1.503969 1.473016 1.443964 1.416697 1.391104 1.367084 1.344538 \n       9       10       11       12       13       14       15       16 \n1.323377 1.303516 1.284875 1.267378 1.250957 1.235543 1.221077 1.207499 \n      17       18       19       20       21       22       23       24 \n1.194755 1.182793 1.171566 1.161029 1.151139 1.141856 1.133144 1.124966 \n      25       26       27       28       29       30       31       32 \n1.117291 1.110087 1.103326 1.096980 1.091024 1.085433 1.080186 1.075261 \n      33       34       35       36       37       38       39       40 \n1.070639 1.066300 1.062228 1.058406 1.054819 1.051452 1.048292 1.045326 \n      41       42       43       44       45       46       47       48 \n1.042542 1.039930 1.037477 1.035175 1.033015 1.030987 1.029084 1.027298 \n      49       50       51       52       53       54       55 \n1.025621 1.024048 1.022571 1.021184 1.019883 1.018662 1.017516 \n\n\nThen, we multiply the initial value (the number of cases on March 16) by the cumulative \\(\\hat{r}_{it}\\) starting on \\(t = 4\\). Note that we could produce forecasts for the next 55 days since Italy was at the 55th day after the 100th case. Also, we could produce a new forecast path everyday updating the actual value for \\(C\\). This would certainly make our forecasts more accurate, since we would not carry forward wrong values predicted for \\(t = 2, 3,..., T\\). But to keep the exercise simple, let’s suppose a single path completely built from \\(C_3 = 235\\).\n\nMarch 17: \\(235 \\times 1.44 = 338\\)\nMarch 18: \\(235 \\times 1.44 \\times 1.41 = 477\\)\nMarch 19: \\(235 \\times 1.44 \\times 1.41 \\times 1.39 = 663\\)\n\nWe can get rid of manual calculations by creating a function that takes these arguments – \\(C\\), \\(t\\) and the regression model – and deliver the estimated number of total cases for \\(t+k\\).\n\ncovid_fc <- function(model, C, t){\n  mod_fitted <- fitted(model)\n  r_t        <- 1+exp(mod_fitted)/100 \n  r_t_cum    <- r_t[t:length(r_t)] %>%  cumprod()\n  out <- round(C*r_t_cum, 0)\n  return(out)\n}\ncovid_fc(fit_reg$Italy, 235, 4)\n\n     4      5      6      7      8      9     10     11     12     13     14 \n   339    481    669    914   1229   1627   2120   2725   3453   4320   5337 \n    15     16     17     18     19     20     21     22     23     24     25 \n  6517   7869   9402  11120  13028  15126  17412  19882  22529  25345  28317 \n    26     27     28     29     30     31     32     33     34     35     36 \n 31435  34683  38046  41510  45056  48669  52332  56028  59743  63461  67167 \n    37     38     39     40     41     42     43     44     45     46     47 \n 70849  74494  78092  81632  85104  88503  91819  95049  98187 101230 104174 \n    48     49     50     51     52     53     54     55 \n107018 109760 112399 114936 117371 119705 121939 124074 \n\n\nSince our models are stored in a list object, we can use the map function to compute the results for both of them at once.\n\ncovid_br_fc <- \n  map(\n    .x = fit_reg,\n    .f = ~ covid_fc(.x, 235, 4) %>% \n      as.data.frame() %>% \n      tibble::rownames_to_column() %>% \n      magrittr::set_colnames(c('t', 'forecast')) %>% \n      mutate(t = as.numeric(t))\n  ) %>% \n  plyr::ldply(.id = 'country') %>% \n  pivot_wider(names_from = 'country', values_from = 'forecast')\n\nIt’s much easier to look at the results graphically.\n\n\nShow the code\ndata_plot <- covid_data_aux %>% \n  filter(Country.Region == 'Brazil') %>% \n  select(date, t, observed = acum_cases) %>%\n  left_join(covid_br_fc) %>% \n  select(-t)\ndata_plot %>% \n  filter(date <= '2020-04-01' & date >= '2020-03-17') %>% \n  pivot_longer(cols = -c('date'), names_to = 'var', values_to = 'value') %>% \n  ggplot(aes(x = date)) +\n  geom_line(aes(y = value, color = var), lwd = 1) +\n  theme_light() +\n  scale_x_date(date_breaks = '3 days', date_labels = '%b %d') +\n  scale_y_continuous(labels = function(x) format(x, big.mark = '.')) +\n  theme(\n    legend.position = 'top', \n    axis.text = element_text(size = 13),\n    legend.text = element_text(size = 13)\n    ) +\n  labs(title = 'Covid total cases in Brazil - Observed vs. Forecasts',\n       subtitle = 'Estimated on March 16',\n       x = '', y = 'Total Cases', color = '') \n\n\n\n\n\nThe actual values for Brazil were very close to those recorded by the two countries in the short-term and lied between the two curves in the mid-term – although I have not updated the forecasts here, something I did at the time. This result shows how simple exercises can play a significant role in real cases. In fact, we successfully relied on this strategy for a couple of months. At the time, both models produced good one up to seven-step-ahead forecasts since the beginning. For longer horizons, the Iran-like model delivered fairly stable accuracy, while the Italy-like model surprisingly improved over time."
  },
  {
    "objectID": "fc_comparison.html#the-second-wave-in-brazil",
    "href": "fc_comparison.html#the-second-wave-in-brazil",
    "title": "7  Forecasting by comparison",
    "section": "7.2 The second wave in Brazil",
    "text": "7.2 The second wave in Brazil\nQuestions shift very rapidly in the financial markets. After some time, we were experiencing the second wave of Covid in Brazil and a set of containing restrictions were in place. As we approached important dates for local retail businesses, the big question was whether those restrictions would be lifted in time not to cause major demage to the economy.\nNote that it’s no more a matter of simply predicting new cases for the next days. This time we needed an estimate for the second wave peak and how fast the subsequent decline would be – these parameters served as triggers for policy decisions. Once again, Brazil was a latecomer in this process as several countries had already gone through the second wave. So with the appropriate ideas we could benefit from this condition.\nIn general, how long does it take to reach the peak after the second wave has started? How long does it take to go down to the bottom after reaching the peak? The first challenge here is that the second wave occurred in a non-synchronized way between countries. The number of days around the peak wasn’t the same either. However, looking at the plot below we can see a large number of peaks occurring in the period between November 2020 and March 2021. At the time, I assumed it as the typical period where the second wave took place. Note that some countries had started a third wave, but I couldn’t rely on these information since this new cycle was not complete yet.\n\n\nShow the code\ncovid_data <- read_csv('data/owid-covid-data.csv')\ncovid_data %>% \n  filter(date <= '2021-05-01') %>% \n  ggplot(aes(x = date)) +\n  geom_line(aes(y = new_cases_smoothed, color = location)) +\n  theme_light() +\n  theme(legend.position = 'none') +\n  scale_y_continuous(labels = function(x) format(x, big.mark = '.')) +\n  scale_x_date(date_breaks = '2 months', date_labels = '%b/%y') +\n  annotate(\n    \"rect\",\n    xmin = as.Date('2020-11-01'),\n    xmax = as.Date('2021-03-01'),\n    ymin = -Inf, ymax = Inf,\n    alpha = .2) +\n  labs(title = 'Covid New Cases (smoothed) by country',\n       subtitle = 'Shaded Area = assumed 2nd wave',\n       x = '', y = 'Covid New Cases (smoothed)')\n\n\n\n\n\nThe idea I came up with was to zoom-in on this period and then compute the typical behavior of new cases around the peak. First, I filtered the November 2020 - March 2021 period excluding Brazil from the data set. Next, I created a variable peak_date as the earliest date where each country recorded the maximum number of new cases in the period. I also created the variable t_around_peak to count the number of days before and after the peak date. Finally, I computed the median, first and third quartiles from the distribution of new cases for every t_around_peak. But notice that I had standardized (scaled) the data in order to prevent countries with higher (lower) numbers from over(under)weight the statistics.\n\ncovid_2nd_wave <- covid_data %>%\n  select(date, continent, location, new_cases_smoothed) %>% \n  filter(\n    location != 'Brazil',\n    between(date, as.Date('2020-11-01'), as.Date('2021-04-01'))\n  ) %>% \n  group_by(location) %>%\n  mutate(\n    peak_date = min(date[which(new_cases_smoothed == max(new_cases_smoothed, na.rm = TRUE))]),\n    t_around_peak = (date - peak_date) %>% as.numeric(),\n    new_cases_smoothed_std = scale(new_cases_smoothed)) %>%\n  ungroup() %>% \n  filter(\n    !is.na(peak_date)\n    ) %>% \n  group_by(t_around_peak) %>% \n  summarise(\n    median = median(new_cases_smoothed_std, na.rm = TRUE),\n    lower  = quantile(new_cases_smoothed_std, probs = 0.25, na.rm = TRUE),\n    upper  = quantile(new_cases_smoothed_std, probs = 0.75, na.rm = TRUE)\n  ) %>% \n  ungroup()\n\n\n\nShow the code\ncovid_2nd_wave %>% \n  filter(between(t_around_peak, -80, 80)) %>% \n  ggplot(aes(x = t_around_peak)) +\n  geom_line(aes(y = median)) +\n  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.3, fill = 'grey70') +\n  theme_light() +\n  scale_x_continuous(breaks = seq(-80, 80, 20)) +\n  labs(\n    title = 'Covid 2nd wave typical distribution around the peak',\n    x = '# of days before (-) and after (+) peak',\n    y = 'New cases smoothed (scaled)'\n  )\n\n\n\n\n\nOn average, the number of new cases grew rapidly for 20 days until it peaked and then took about the same amount of days to reach the bottom. In addition, there was greater uncertainty about the behavior of the pre-peak period as showed in the shaded area. Once again, the exercise proved to be very helpful as the realized values were in line with expectations."
  },
  {
    "objectID": "fc_simulation.html",
    "href": "fc_simulation.html",
    "title": "8  Simulations",
    "section": "",
    "text": "For example, suppose that it’s widely known that the PCI increases by around 0.5p.p for every 10% of exchange rate depreciation in a given country. In this case we can make predictions for the PCI based on what we expect for the exchange rate in different scenarios (all other things being equal): in scenario A, it increases by 5%; in scenario B, it decreases by 7%; and so on.\nThis approach is widely used and although very useful it has some limitations. The most important limitation is that it does not provide a complete distribution of predictions from which it would be possible to infer the correct uncertainty around the central value. The common practice is to set scenarios for both the upper and lower bounds and assume that all values fall within this range with the same probability.\nHowever, in many situations we do have a grasp of the risks for each scenario: it’s more likely that the exchange rate shows a positive rather than a negative variation by the end of the year, for instance. Also, it may be that our prediction depends on the scenarios for more than one single variable. In that case, we also need to consider the interaction among the possible values for all the variables.\nAn elegant solution to deal with these issues is to generate distributions that reflect our scenario for each variable and then simulate a large number of joint scenarios for the outcome. To get a better sense of this idea, think about a common example from macroeconomics textbooks: the evolution of public debt. For the sake of simplicity, assume that the debt-to-GDP ratio evolves according to the following expression:\n\\[ \\Delta b_{t+1} = (r_{t+1} - g_{t+1}) \\times b_{t} - s_{t+1} \\]\nwhere \\(b\\) is the debt-to-GDP ratio; \\(r\\) is the real interest rate; \\(g\\) is the real GDP growth rate; and \\(s\\) is the government primary surplus as proportion of the GDP.\nNow suppose the following assumptions for the variables on the RHS of the above equation: 1. CPI would be around the target at, say, 2% but with a higher probability of ending the year above rather than below the target; 2. The GDP is expected to grow 3%, but with downwards risks; 3. Interest rate will be raised either to 3% with a 40% chance or to 4% with a 60% chance; and primary surplus will be zero, with no uncertainty.\nWe’ll start by building skewed distributions for both CPI and GDP using the sn package. The first step is to supply the parameters of a Gaussian distribution – mean and standard deviation – plus a parameter gamma that controls the degree of skewness. Then we use the rsn function to sample random values from the distributions generated by these parameters. As for the interest rate variable, we can just use the sample function.\n\nlibrary(tidyverse)\nlibrary(sn)\nset.seed(123)\nsn_parameters <- map(\n  .x = list(\n    \"CPI\" = c(mean = 2.0, s.d. = 0.4, gamma = 0.8),\n    \"GDP\" = c(mean = 3.0, s.d. = 0.6, gamma = -0.8)\n  ),\n  .f = cp2dp, family = 'sn'\n)\n# Number of simulations\nn_sim <- 1000\nvariables_sim <- tibble(\n  CPI  = rsn(n_sim, dp = sn_parameters[['CPI']]),\n  GDP  = rsn(n_sim, dp = sn_parameters[['GDP']]),\n  IR   = sample(c(3.0, 4.0),  n_sim, \n                prob = c(0.40, 0.60), \n                replace = TRUE\n  )\n)\n\nDefining the values of the gamma parameter is largely a matter of trial and error until we get the desired shape of the distribution. I somewhat exaggerated the parameter values to make the asymmetry of the distributions obvious. In addition, we must be cautious about the number of simulations since it’s very memory consuming. Below we can check visually the results.\n\nvariables_sim %>% \n  rowid_to_column(var = 'n') %>% \n  pivot_longer(-n, names_to = 'var', values_to = 'value') %>% \n  ggplot(aes(x = value)) +\n  geom_histogram(fill = \"steelblue2\", alpha = 0.8) +\n  theme_bw() +\n  scale_x_continuous(labels = function(x) paste0(x, '%')) +\n  facet_wrap(~ var, scales = 'free_y') +\n  labs(\n    title = 'Asymmetric Distributions',\n    x = \"value\",\n    y = \"n\"\n  )\n\n\n\n\nNext we’ll use the cross function from the purrr package to create all the combinations of the three variables – our scenarios under the assumption that they are independent1.\n\n\n\n\nscenarios_sim <- cross3(\n  .x = variables_sim$CPI,\n  .y = variables_sim$GDP,\n  .z = variables_sim$IR\n)\n\nFinally, we compute the debt-to-GDP equation for each scenario assuming the initial debt-to-GDP is 60%.\n\ndebt2gdp_sim <- map_dbl(\n  .x = scenarios_sim, \n  .f = function(x){\n    x <- unlist(x)\n    CPI  <- x[1]\n    GDP  <- x[2]\n    IR   <- x[3]\n    r    <- IR - CPI\n    b0   <- 60.0\n    b1   <- (r - GDP)*(b0/100)\n    return(b1)\n  }\n)\nsummary(debt2gdp_sim)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n-2.7844 -1.2214 -0.8608 -0.8786 -0.5269  0.9323 \n\n\nWe can check some interesting statistics about the resulting distribution with the summary function. In the most extreme scenarios the debt-to-GDP ratio would increase by summary(debt2gdp_sim)['Max.]p.p or decrease by summary(debt2gdp_sim)[Min.]p.p, while the expected scenario is a more modest drop around summary(debt2gdp_sim)['Median'] p.p. Also, at least 75% of the values in the distribution are negative.\n\n\nShow the code\ntibble(b1 = debt2gdp_sim) %>% \n  ggplot(aes(x = b1)) +\n  geom_histogram(fill = \"steelblue3\") +\n  labs(title = \"Debt-to-GDP variation for the next period (p.p)\",\n       y = \"Frequency\", x = \"Variation (p.p)\") +\n  theme(axis.text = element_text(size = 12),\n        title = element_text(size = 12)) +\n  theme_light()\n\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\nIt would be more realistic, for example, that the interest rate would assume the 4% value if inflation was above the target. We could create rules to account for this kind of dependency and use them to filter the variables_sim data frame – taking care not to drastically distort the probabilities assigned to each variable at the start.↩︎"
  },
  {
    "objectID": "ss_intro.html",
    "href": "ss_intro.html",
    "title": "9  Introduction",
    "section": "",
    "text": "After a brief introduction, the next two sections will focus on basic applications of SS models: 1. Estimate a common underlying process when there are multiple sources of information; 2. Estimate time-varying coefficients from regression models; and 3. Estimate latent (unobservable) variables For those interested in delving into the details of the subject, I strongly recommend start by reading the excellent Holmes, Scheuerell, and Ward (2021) (http://www2.uaem.mx/r-mirror/web/packages/MARSS/vignettes/UserGuide.pdf) – which will be a valuable reference for the following applications.\nLet’s think about state-space models as a representation of an idea rather than a method. Suppose we need to measure air temperature in Rio de Janeiro city. We can’t observe it directly, but we have available data collected by a sensor. This sensor performs very well on average, although it’s subject to measurement errors. The main goal is to accurately estimate the real air temperature from the somewhat noisy data we get from the sensor.\nIn the SS representation, this problem is summarised by two equations. The observation equation tell us the data we observe (\\(y_t\\)) is the real temperature (\\(x_t\\)) plus \\(v_t\\) which is a Gaussian error with zero mean and variance \\(\\sigma^2_v\\). We could add terms for seasonality, exogenous regressors or dummies variables as well. For now, we’ll stick to the simplest specification.\n\\[\n\\begin{align}\ny_t = Z_tx_{t} + v_t\n\\end{align}\n\\]\nThe state process (or transition) equation describes how the unobservable real air temperature (the hidden state, \\(x_t\\)) evolves over time. It’s usually characterized by an autoregressive process – often a random walk –, where \\(w_t\\) is also a Gaussian error term with zero mean and variance \\(\\sigma^2_w\\).\n\\[\n\\begin{align}\nx_t = B_tx_{t-1} + w_t\n\\end{align}\n\\] Finding the hidden state trajectory requires us to solve for this linear stochastic dynamical system, which can be accomplished by several algorithms – the most known are the Expectation Maximization (EM) and the Kalman Filter and Smoother, the latter you may already have heard of. In the next two sections, we’ll see how to build and estimate such models with the MARSS package.\n\n\n\n\nHolmes, E. E., M. D. Scheuerell, and E. J. Ward. 2021. Analysis of Multivariate Time Series Using the MARSS Package, Version 3.11.4. NOAA Fisheries, Northwest Fisheries Science Center."
  },
  {
    "objectID": "ss_tv_coef.html",
    "href": "ss_tv_coef.html",
    "title": "10  Time-varying regression coefficient",
    "section": "",
    "text": "For this exercise we’ll use the CPI in Brazil excluding regulated prices such as public transport, energy and others. After importing the series from the Brazilian Central Bank API with the rbcb package, we’ll compute the seasonally-adjusted series on the original data with the seasonal package (see (seasonality?)).\n\nlibrary(tidyverse)\nlibrary(rbcb)\nlibrary(seasonal)\ncpi_br <- get_series(\n  code = 11428,\n  start_date = \"2004-01-01\",\n  end_date = \"2022-12-01\",\n  as = \"ts\"\n)\ncpi_br_sa <- final(seas(cpi_br))\ncpi_br_df <- cpi_br_sa %>%\n  timetk::tk_tbl(rename_index = 'date') %>%\n  rename(c('cpi_sa' = value)) %>% \n  mutate(\n    cpi_sa_lagged = dplyr::lag(cpi_sa, 1)\n  ) %>% \n  drop_na()\n\n\n\nShow code\ncpi_br_df %>% \n  ggplot(aes(x = date, y = cpi_sa)) +\n  geom_line(lwd = 1) +\n  theme_light() +\n  scale_y_continuous(labels = function(x) paste0(x, '%')) +\n  labs(\n    title = 'Brazilian CPI ex-regulated prices (%)',\n    subtitle = 'Seasonally-adjusted',\n    x = '', y = '% SA'\n  )\n\n\n\n\n\nWe’re primarily interested in estimating the \\(Z_t\\) matrix, which contains the coefficient associated to the hidden state process \\(x_t\\) – which represents the \\(\\beta\\) coefficient in this case. However, instead of a single coefficient, we’ll have one for each \\(t\\). This has implications for how we should declare the model objects to the MARSS function. In particular, time-varying parameters are specified by passing in an array of matrices where the second dimension of the array is the data and the third dimension is time.\nIt’s worth noting that in this case we might have two time-varying coefficients – the \\(\\beta\\) for the lagged inflation and the intercept term. If we wanted the intercept term to be time-varying, we should place it inside the second dimension of the \\(Z\\) matrix. We’ll do it for demonstration purposes only. However, by setting the variance of the intercept term equal to zero in the \\(Q\\) matrix – the first diagonal element – we’re making it deterministic. The two main lessons here are: 1. Everything we want to be time-varying should be placed in the \\(Z\\) matrix and, thus, related to the state process; and 2. We can make a state variable deterministic by setting its variance to zero.\n\nlibrary(MARSS)\n# Variables\nt         <- nrow(cpi_br_df)\ny         <- matrix(cpi_br_df$cpi_sa, nrow = 1) \ny_lagged  <- matrix(cpi_br_df$cpi_sa_lagged, nrow = 1)\n# Model specification\nB         <- diag(2)\nQ         <- matrix(list(0,0,0,\"sigma.ar1\"), 2, 2)\nZ         <- array(NA, c(1, 2, t))\nZ[1, 1, ] <- rep(1, t) # Intercept term \nZ[1, 2, ] <- y_lagged\nR         <- matrix(\"r\")\nA         <- matrix(0)\nx0        <- list(x0 = matrix(0, nrow = 2)) # initial values\nss_terms  <- list(B = B, Q = Q, Z = Z, A = A, R = R)\nss_fit    <- MARSS(y, inits = x0, model = ss_terms, silent = TRUE)\n# Use the Kalman Filter and Smoother\nss_fit_kf <- MARSSkfss(ss_fit)  \n\nAfter the process of estimating the model is finished, we can extract the time-varying \\(\\beta\\) located in the second row of the states element – the first row is the deterministic intercept. It would be interesting to compare it with the time-constant coefficient estimated from a standard AR(1). The results from the two models are shown below together with the respective confidence intervals. Also, we used the ggtext package which allows us to pass in HTML code to create a custom title for the plot.\n\nlibrary(ggtext)\n## Benchmark\nar1_fit <- arima(cpi_br_sa, order = c(1,0,0))\n## Plot\nout_tidy <- cpi_br_df %>%\n  mutate(\n    coef.dlm      = ss_fit_kf$xtT[2, ],\n    coef.dlm.se   = ss_fit_kf$VtT[2, 2, ],\n    coef.dlm.low  = coef.dlm - 1.96*coef.dlm.se,\n    coef.dlm.high = coef.dlm + 1.96*coef.dlm.se,\n    coef.ar1      = ar1_fit$coef[\"ar1\"],\n    coef.ar1.se   = ar1_fit$var.coef[\"ar1\", \"ar1\"] %>% sqrt(),\n    coef.ar1.low  = coef.ar1 - 1.96*coef.ar1.se,\n    coef.ar1.high = coef.ar1 + 1.96*coef.ar1.se\n    )\n\n\n\nShow the code\nout_tidy %>%\n  ggplot(aes(x = date)) +\n  geom_line(aes(y = coef.dlm), color = \"darkblue\", lwd = 1) +\n  geom_ribbon(aes(ymin = coef.dlm.low, ymax = coef.dlm.high, \n                  xmin = min(date), xmax = max(date)), \n              alpha = 0.3, fill = \"steelblue3\") +\n  geom_ribbon(aes(ymin = coef.ar1.low, ymax = coef.ar1.high, \n                  xmin = min(date), xmax = max(date)), \n              alpha = 0.2, fill = \"red\") +\n  geom_line(aes(y = coef.ar1), color = \"red\", lwd = 1) +\n  theme_light() +\n  theme(plot.title = element_markdown(lineheight = 1.1),\n        axis.title = element_text(size = 13)) +\n  labs(\n    title = \"<span style='color:#002266;'><b>Time-varying</b></span> vs <span style='color:#ff1a1a;'><b>constant</b></span> coefficient\",\n    subtitle = 'Smoothed values',\n    x = \"\", \n    y = \"\"\n    )\n\n\n\n\n\nFor most of the period, we can’t say the time-varying coefficient is statistically different from the static one. However, the value of this approach lies precisely in the timeliness it detects variations in the relationship of interest. Since the prevailing relationship was re-established not so long after the departure was large enough to exceed the confidence bands, it’s very likely that this behavior would go unnoticed in the standard approach. On the other hand, has the departure persisted for many periods ahead the likely effect on the static coefficient would be a progressive shift downwards – which, in turn, would improve the fit in the more recent part of the sample at the expense of a poorer fit elsewhere.\nRemember that by using the smoothed values we are, in fact, using the information provided by the entire sample. To see whether this changing behavior of \\(\\beta\\) would be spotted in real-time, we should use the filtered values - \\(xtt\\) and \\(Vtt\\).\n\nout_filtered_tidy <- cpi_br_df %>%\n  mutate(\n    coef.dlm      = ss_fit_kf$xtt[2, ],\n    coef.dlm.se   = ss_fit_kf$Vtt[2, 2, ],\n    coef.dlm.low  = coef.dlm - 1.96*coef.dlm.se,\n    coef.dlm.high = coef.dlm + 1.96*coef.dlm.se,\n    coef.ar1      = ar1_fit$coef[\"ar1\"],\n    coef.ar1.se   = ar1_fit$var.coef[\"ar1\", \"ar1\"] %>% sqrt(),\n    coef.ar1.low  = coef.ar1 - 1.96*coef.ar1.se,\n    coef.ar1.high = coef.ar1 + 1.96*coef.ar1.se\n  )\n\n\n\nShow the code\nout_filtered_tidy %>%\n  ggplot(aes(x = date)) +\n  geom_line(aes(y = coef.dlm), color = \"darkblue\", lwd = 1) +\n  geom_line(aes(y = coef.ar1), color = \"red\", lwd = 1) +\n  geom_ribbon(aes(ymin = coef.dlm.low, ymax = coef.dlm.high, \n                  xmin = min(date), xmax = max(date)), \n              alpha = 0.3, fill = \"steelblue3\") +\n  geom_ribbon(aes(ymin = coef.ar1.low, ymax = coef.ar1.high, \n                  xmin = min(date), xmax = max(date)), \n              alpha = 0.2, fill = \"red\") +\n  geom_line(aes(y = coef.ar1), color = \"red\", lwd = 1) +\n  theme_light() +\n  theme(plot.title = element_markdown(lineheight = 1.1),\n        axis.title = element_text(size = 13)) +\n  labs(\n    title = \"<span style='color:#002266;'><b>Time-varying</b></span> vs <span style='color:#ff1a1a;'><b>constant</b></span> coefficient\",\n    subtitle = 'Filtered values',\n    x = \"\", \n    y = \"\"\n    )\n\n\n\n\n\n\n\n\n\n\nWe’ll use a AR(1) model for simplicity, but the same logic applies to more complex models.↩︎"
  },
  {
    "objectID": "ss_common.html",
    "href": "ss_common.html",
    "title": "11  Dynamic Factor Model",
    "section": "",
    "text": "Policymakers and analysts are routinely seeking to characterize short-term fluctuation in prices as either persistent or temporary. This issue is often addressed using core measures that exclude those items that are the most volatile or most subject to supply shocks from the inflation index. Eli, Flora, and Danilo (2021) argue that core measures are imperfect measures of underlying inflation in that temporary shocks in sectors that were not filtered out from the index may be misunderstood as economy-wide shocks.\nThe authors propose an alternative measure to deal with this problem. In their words:\nIn fact, this idea is represented by a special class of State-Space models known as Dynamic Factor Model (DFM). In short, DFM allows us to estimate common underlying trends among a relatively large set of time series (see Holmes, Scheuerell, and Ward (2021), chapter 10). Using Eli, Flora, and Danilo (2021) notation, the model has the following structure:\n\\[\n\\pi_{it} = \\chi_{it} + \\xi_{it} \\\\\n\\]\n\\[\n\\chi_{it} = \\lambda_i f_t \\\\\n\\] \\[\nf_t = \\sum_i^p b_i f_{t-i} + u_t \\ \\ \\ \\ u_t \\sim N(0, Q)\n\\] Where \\(\\pi_{it}\\) is the CPI for each subsector \\(i\\), which is the sum of the common trend, \\(\\chi_{it}\\), and the idiosyncratic component, \\(\\xi_{it}\\). In State-Space language, this is the observation equation and \\(\\chi_{it}\\) is the hidden state (\\(x_t\\)). However, in this case the hidden state follows an autoregressive process of order \\(p\\) with \\(p\\) usually higher than 1. In addition, each subsector will have an individual contribution to the common trend given by \\(\\lambda_i\\) – also known as the factor loading."
  },
  {
    "objectID": "ss_common.html#writing-out-the-dfm-as-marss",
    "href": "ss_common.html#writing-out-the-dfm-as-marss",
    "title": "11  Dynamic Factor Model",
    "section": "11.1 Writing out the DFM as MARSS",
    "text": "11.1 Writing out the DFM as MARSS\nWe start by writing out the above DFM in MARSS form. The LHS of the observation equation contains now the \\(k\\) time series corresponding to each observation of the common underlying process, all of them is a function of a single hidden process (the common component) plus a Gaussian innovation term.1\n\\[\n\\underbrace{\n\\begin{bmatrix}\ny_{1t} \\\\\ny_{2t} \\\\\ny_{3t} \\\\\n\\vdots \\\\\ny_{kt}\n\\end{bmatrix}\n}_{y_t}\n=\n\\underbrace{\n\\begin{bmatrix}\nz_1 \\\\\nz_2 \\\\\nz_3 \\\\\n\\vdots \\\\\nz_k\n\\end{bmatrix}\n}_{Z}\n\\begin{bmatrix}\nx_t\n\\end{bmatrix}\n+\nv_t \\text{~ MVN}\n\\begin{pmatrix}\n0,\n\\underbrace{\n\\begin{bmatrix}\n\\sigma^2_{y_{1t}} & 0 & 0 & \\dots & 0 \\\\\n0 & \\sigma^2_{y_{2t}} & 0 & \\dots & 0 \\\\\n0 & 0 & \\sigma^2_{y_{3t}} & \\dots & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\ddots &  0 \\\\\n0 & 0 & 0 & \\dots & \\sigma^2_{y_{kt}}\n\\end{bmatrix}\n}_{R}\n\\end{pmatrix}\n\\] The transition equation, in turn, is a function of its own \\(p\\) lags. In the MARSS form each lag will be represented by a separate variable, although only the first one, \\(x_t\\), will have an autoregressive structure. The others are simply treated as identities.\n\\[\n\\underbrace{\n\\begin{bmatrix}\nx_{t} \\\\\nx_{t-1} \\\\\nx_{t-2} \\\\\n\\vdots \\\\\nx_{t-p+1} \\\\\n\\end{bmatrix}\n}_{x_t}\n=\n\\underbrace{\n\\begin{bmatrix}\nb_1 & b_2 & b_3 & \\dots & b_p \\\\\n1 & 0 & 0 & \\dots & 0 \\\\\n0 & 1 & 0 & \\dots & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & 0 & \\dots & 1\n\\end{bmatrix}\n}_{B}\n\\underbrace{\n\\begin{bmatrix}\nx_{t-1} \\\\\nx_{t-2} \\\\\nx_{t-3} \\\\\n\\vdots \\\\\nx_{t-p}\n\\end{bmatrix}\n}_{x_{t-1}}\n+\nv_t \\sim \\text{MVN}(0, Q)\n\\]"
  },
  {
    "objectID": "ss_common.html#importing-data",
    "href": "ss_common.html#importing-data",
    "title": "11  Dynamic Factor Model",
    "section": "11.2 Importing data",
    "text": "11.2 Importing data\nFor this exercise, we’ll use data on the 51 subsectors that make up Brazilian CPI. All these time series are the monthly percentage change accumulated in the last twelve months. This eliminates the need to add seasonal components to the model.\nFor aesthetic reasons, the piece of code that downloads and prepare the data has been omitted. The interested reader can display it by clicking on ‘Show the code’. Basically, the final output is a A \\(k \\times t\\) matrix of the \\(k\\) subsectors time series over \\(t\\) time steps.\n\n\nShow the code\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(sidrar)\nlibrary(MARSS)\n# Import CPI data\nsidra_codes <- list(\n  'cpi_asof2020'     = '/t/7060/n1/all/v/63/p/all/c315/all/d/v2265%202',\n  'cpi_upto2019'     = '/t/1419/n1/all/v/63/p/all/c315/all/d/v2265%202',\n  'weights_asof2020' = '/t/7060/n1/all/v/66/p/all/c315/all/d/v2265%202',\n  'peso_upto2019'    = '/t/1419/n1/all/v/66/p/all/c315/all/d/v2265%202'\n  )\ncpi_data   <- purrr::map(.x = sidra_codes, .f = ~ get_sidra(api = .x))\ncpi_df <- cpi_data %>% \n  plyr::ldply() %>% \n  select(\n    var   = `Variável`, \n    item  = `Geral, grupo, subgrupo, item e subitem`,\n    date  = `Mês (Código)`,\n    value = Valor\n  ) %>% \n  mutate(\n    item = ifelse(item == 'Índice geral', '1001.CPI Headline', item),\n    var  = ifelse(str_detect(var, 'Variação'), 'CPI', 'Weight')\n    ) %>% \n  separate(col = item, into = c('code', 'item'), sep = '\\\\.') %>% \n  mutate(date = paste0(date, '01') %>% ymd()) %>% \n  mutate(across(contains('code'), ~ as.numeric(.x))) %>% \n  relocate(date) %>%\n  filter(str_length(code) == 4) %>% \n  unite(col = 'item', c('code', 'item'), sep = '.') %>% \n  arrange(date) %>% \n  plyr::dlply(.variables = 'var') %>% \n  map(.f = ~ .x %>% select(-var))\n\nCPI_reg <- cpi_df$CPI %>% \n  tidyr::pivot_wider(names_from = 'item', \n                     values_from = 'value') %>% \n  dplyr::select(where(~ sum(is.na(.x)) == 0))\n\nCPI_twelveMonths <- CPI_reg %>% \n  arrange(date) %>% \n  mutate(across(-date, ~ ((RcppRoll::roll_prodr(1+.x/100, 12))-1)*100)) %>% \n  filter(between(date, ymd('2012-12-01'), ymd('2022-12-01')))\nCPI_ts <- CPI_twelveMonths %>% \n  arrange(date) %>%\n  select(-c(date, contains('geral'))) %>%\n  ts(start = c(2012,12), freq = 12) %>% \n  as.matrix() %>% \n  t()"
  },
  {
    "objectID": "ss_common.html#estimating-the-model",
    "href": "ss_common.html#estimating-the-model",
    "title": "11  Dynamic Factor Model",
    "section": "11.3 Estimating the model",
    "text": "11.3 Estimating the model\nNext, we declare the system’s matrices. Note that by defining the \\(R\\) matrix as diagonal and unequal, we are assuming that prices across the subsectors are independent. This is arguably a very strong assumption, but considering cross-dependence between subsectors would greatly increase the number of parameters to be estimated.\n\n# Define model's specification\nmodel.spec   <- list()\nmodel.spec$B <- matrix(\n  list(\n    \"b1\", 1, 0, 0, \n    \"b2\", 0, 1, 0, \n    \"b3\", 0, 0, 1, \n    \"b4\", 0, 0, 0\n    ), 4, 4)\nmodel.spec$Z <- matrix(\n  list(0), nrow(CPI_ts), 4)\nmodel.spec$Z[, 1] <- rownames(CPI_ts)\nmodel.spec$Q <- \"diagonal and equal\"\nmodel.spec$R <- \"diagonal and unequal\"\nmodel.spec$A <- \"zero\" \n# Estimate using the EM Algorithm\nmodel.em <- MARSS(CPI_ts, model = model.spec, inits = list(x0 = 0), silent = TRUE)"
  },
  {
    "objectID": "ss_common.html#results",
    "href": "ss_common.html#results",
    "title": "11  Dynamic Factor Model",
    "section": "11.4 Results",
    "text": "11.4 Results\nAfter estimating the system, we are ready to compute the common inflation component, \\(\\chi_{it}\\). Basically, \\(\\chi_{it}\\) is the dot product of the \\(\\lambda_i\\) elements (which is the \\(Z\\) matrix) and \\(f_t\\) (which is the estimate of the hidden state, \\(x_t\\)). The aggregate common inflation is obtained as the sum of the contributions of each individual subsector to the headline CPI, using their original weights.\n\n# Compute model's components\nft         <- model.em$states[1, ]\nnames(ft)  <- CPI_twelveMonths$date\nft_df      <- ft %>% \n  as.data.frame() %>% \n  rownames_to_column() %>% \n  magrittr::set_colnames(c('date', 'ft'))\nlambda   <- model.em$par$Z %>% \n  as.data.frame() %>% \n  tibble::rownames_to_column() %>% \n  magrittr::set_colnames(c('item', 'lambda'))\nchi_it   <- lambda %>% \n  mutate(\n    chi_it = map(\n      .x = lambda, \n      .f = ~ {\n        df <- .x*ft %>% \n          as.data.frame()\n        df <- df %>% \n          rownames_to_column() %>% \n          magrittr::set_colnames(c('date', 'chi_it')) %>% \n          mutate(date = ymd(date))\n      }\n    ) \n  ) %>% \n  unnest(chi_it) %>% \n  left_join(\n    cpi_df$Weight %>% \n      rename(c('weight' = 'value'))\n  ) %>% \n  relocate(date)\n# Commpute the common trend\ncommon_trend <- chi_it %>% \n  group_by(date) %>% \n  summarise(\"Common Inflation\" = sum(chi_it*weight)/sum(weight)) %>%  \n  ungroup() %>% \n  left_join(\n    CPI_twelveMonths %>% \n      select(date, `CPI Headline` = contains('CPI'))\n  )\n\n\n\nShow the code\ncommon_trend %>% \n  pivot_longer(-date, names_to = 'var', values_to = 'value') %>% \n  ggplot(aes(x = date)) +\n  geom_line(aes(y = value, color = var), lwd = 1) +\n  theme(legend.position = 'top') +\n  labs(\n    title = 'Brazil Common Inflation - % 12-month',\n    x = '',\n    y = '% 12-month',\n    color = '')\n\n\n\n\n\n\n\n\n\nEli, Nir, Haberkorn Flora, and Cascaldi-Garcia Danilo. 2021. “International Measures of Common Inflation.”\n\n\nHolmes, E. E., M. D. Scheuerell, and E. J. Ward. 2021. Analysis of Multivariate Time Series Using the MARSS Package, Version 3.11.4. NOAA Fisheries, Northwest Fisheries Science Center."
  },
  {
    "objectID": "single_equation.html",
    "href": "single_equation.html",
    "title": "12  Single equation models",
    "section": "",
    "text": "In this section, we’ll see how to estimate the parameters of a simple reduced form Phillips Curve, check basic properties of the model and extract some useful information from it. It’s worth noting that the same procedures applies for any other custom model.\nFor this exercise, we’ll use seasonally-adjusted quarterly data from the Brazilian economy ranging from 2004Q1 to 2022Q4. The basic Phillips Curve can assume the following form:\n\\[ \\pi_t = \\beta_1\\pi_{t-1} + \\beta_2\\pi^{e}_{t,t+4|t} + \\beta_3\\Delta e_{t-1} + \\beta_4\\tilde{y}_{t-1} + \\epsilon_t \\] where \\(\\pi_t\\) is a measure of inflation; \\(\\pi^{e}_{t,t+4|t}\\) is the expected inflation in \\(t\\) for \\(t+4\\); \\(e\\) is a measure of exchange rate or imported inflation; and \\(\\tilde{y}\\) is a measure of output gap. In this exercise, \\(\\pi_t\\) is a measure of core inflation which excludes food-at-home and regulated prices (CPI_CORE); \\(\\pi^{e}\\) is the market expectations compiled by the Brazilian Central Bank (CPI_EXP); \\(e\\) is an index of commodities prices in USD (CI_USD); and \\(\\tilde{y}\\) is the cycle component obtained from the HP Filter on the GDP series (YGAP).\nLet’s start by importing the data set and visualizing the variables of interest.\n\n\nShow the code\nlibrary(tidyverse)\nlibrary(lubridate)\ncp_data <- readRDS('data/ch12_cp_data.rds')\ncp_data %>% \n  pivot_longer(-date, 'var', 'value') %>% \n  ggplot(aes(x = date, y = value)) +\n  geom_line(lwd = 1) +\n  theme_light() +\n  facet_wrap(~ var, scales = 'free_y') +\n  labs(\n    title = 'Phillips Curve variables',\n    x = '',\n    y = ''\n  )\n\n\n\n\n\nNext, we need to create the appropriate variables for lagged CPI and YGAP and the percentage change of CI_USD. Then, we fit the model to the data. Note that we are imposing no restrictions on the coefficients at this point, although the structural version of the Phillips curve does (we’ll see how to do so in the next section). In addition, we are using OLS to estimate the coefficients, although a endogeneity-robust method such as the Generalized Method of Moments (GMM) is more suitable.\n\ncp_reg_data <- cp_data %>% \n  select(date, CPI_CORE, CPI_EXP, CI_USD, YGAP) %>% \n  mutate(\n    CPI_CORE_lag = dplyr::lag(CPI_CORE, 1),\n    YGAP_lag     = dplyr::lag(YGAP, 1),\n    dlog_CI_USD  = log(CI_USD/dplyr::lag(CI_USD))*100\n  )\ncp_fit <- lm(CPI_CORE ~ CPI_CORE_lag + CPI_EXP + YGAP_lag + dlog_CI_USD -1, cp_reg_data)\nsummary(cp_fit)\n\n\nCall:\nlm(formula = CPI_CORE ~ CPI_CORE_lag + CPI_EXP + YGAP_lag + dlog_CI_USD - \n    1, data = cp_reg_data)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.79874 -0.19115 -0.03149  0.16141  0.85059 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \nCPI_CORE_lag 0.656741   0.092798   7.077 8.48e-10 ***\nCPI_EXP      0.089305   0.026820   3.330 0.001381 ** \nYGAP_lag     0.031710   0.011866   2.672 0.009339 ** \ndlog_CI_USD  0.017335   0.004462   3.885 0.000227 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.3169 on 71 degrees of freedom\n  (1 observation deleted due to missingness)\nMultiple R-squared:  0.9551,    Adjusted R-squared:  0.9526 \nF-statistic: 377.6 on 4 and 71 DF,  p-value: < 2.2e-16\n\n\nThe coefficients are highly significant and show the expected signs. To check the model validity, it’s crucial that the residuals are zero-mean and exhibit no clear trend. The checkresiduals functions from the forecast package provides a handy summary of the model residuals.\n\nforecast::checkresiduals(cp_fit)\n\n\n\n\n\n    Breusch-Godfrey test for serial correlation of order up to 10\n\ndata:  Residuals\nLM test = 24.948, df = 10, p-value = 0.005445\n\n\nWe can see that the residuals are well-behaved: mean around zero, no outliers and no clear trend. There is an autocorrelation signal in the third lag evidenced by the ACF, but given that it is relatively small and far enough away, I believe it can be overlooked.\nThe next step is to visualize the model fit. We can use the augment function from the broom package, which returns a data frame with the fitted values, residuals, etc. The broom package also provides other functions that greatly facilitate the manipulation of the regression results, as we’ll see later.\n\nlibrary(broom)\ncp_fit_plot <- cp_fit %>% \n  augment() %>% \n  left_join(\n    cp_reg_data %>% \n      select(date) %>% \n      rowid_to_column(var = '.rownames') %>% \n      mutate(.rownames = as.character(.rownames))\n  )\ncp_fit_plot %>% \n  ggplot(aes(x = date)) +\n  geom_line(aes(y = CPI_CORE, color = 'Observed'), lwd = 1) +\n  geom_line(aes(y = .fitted, color = 'Model'), lwd = 1) +\n  theme_light() +\n  theme(legend.position = 'top') +\n  labs(\n    title = 'CPI Core: Observed vs. Fitted (%QoQ SA)',\n    x = '',\n    y = '%',\n    color = ''\n  )\n\n\n\n\nWhat is the role of economic activity in inflation in recent quarters? And about external factors, did they play a significant role in the overall result? It’s a common practice to quantify the contribution of each variable to the observed value in a given period. This type of decomposition is obtained by multiplying the value of each variable in the period by the respective model coefficient.\nThis time, we can make use of the tidy function from the broom package which returns the model’s coefficients in tidy format.\n\ncp_decomp <- cp_fit_plot %>% \n  select(date, names(cp_fit$coefficients)) %>% \n  pivot_longer(-date, names_to = 'term', values_to = 'value') %>% \n  left_join(\n    cp_fit %>% \n      broom::tidy() %>% \n      select(term, estimate)\n  ) %>% \n  mutate(contribution = value*estimate) %>% \n  bind_rows(\n    cp_fit_plot %>% \n      select(date, contribution = .resid) %>% \n      mutate(term = 'residual')\n  )\ncp_decomp %>% \n  ggplot(aes(x = date)) +\n  geom_col(aes(y = contribution, fill = term)) +\n  theme_light() +\n  scale_fill_brewer(type = 'qual', palette = 6) +\n  labs(\n    title = 'Contribution of each variable to Core CPI (p.p)',\n    x = '', \n    y = '', \n    fill = 'Variable'\n  )\n\n\n\n\nWe can see that inertia and expectations are the main drivers of inflation throughout the sample, although for specific periods economic activity and imported inflation played a significant role. I also included the residual term because it’s also important to know when factors other than those incorporated into the model are relevant to the outcome and the magnitude of its contribution to the overall result."
  },
  {
    "objectID": "multiple_equations.html",
    "href": "multiple_equations.html",
    "title": "13  Multiple equations model",
    "section": "",
    "text": "For example, interest rate hikes are expected to lower inflation through their contractionary impact on economic activity. In addition, the more restrictive monetary policy stance should lead to an appreciation of the exchange rate through greater capital inflows – this is especially true for emerging markets. In the Phillips Curve we saw in the previous section, all these links were present but implicit. We could make all these links explicit by creating specific equations for both the exchange rate and capital inflows. In summary, working with systems of endogenous equations makes it possible to greatly expand the scope of the analysis by incorporating any conceived relationship.\nThis can be cumbersome to do manually, but it becomes quite simple with the bimets package. It provides a very concise and friendly interface to write down the whole system of equations, estimate its parameters and forecast based on scenarios for the exogenous variables. Those who want to delve deeper into all the features available in the package can refer to the vignette. For the purpose of this section, it will suffice to present a variation of the standard three-equation macroeconomic model composed of an IS curve, a Phillips Curve and a Monetary policy rule. The model is described as follows.\nThe IS curve relates the output gap to its own lag, the deviation of the real ex-ante interest rate from its equilibrium and the deviation of the terms of trade from its trend.\n\\[ \\tilde{y_t} = \\beta_1\\tilde{y}_{t-1} + \\beta_2(i_t - \\pi^{e}_{t,t+4|t} - i^{eq}_t)_{t-3} + \\beta_3\\tilde{ToT}_t + \\epsilon^{\\tilde{y}}_t \\] The Phillips Curve is the same from the previous section and relates the core CPI to its own lag, the expectation for the next twelve months, the percentage change in imported prices and output gap.\n\\[ \\pi_t = \\beta_4\\pi_{t-1} + \\beta_5\\pi^{e}_{t,t+4|t} + (1-\\beta_4 - \\beta_5)\\Delta e_{t-1} + \\beta_7\\tilde{y}_{t-1} + \\epsilon_t^{\\pi} \\] Lastly, the monetary policy rule relates the nominal interest rate to its own lags, the deviation of expected inflation from the target and the nominal equilibrium rate.\n\\[ i_t = \\beta_8i_{t-1} + \\beta_9i_{t-2} + (1-\\beta_8-\\beta_9)(\\pi^{e}_{t,t+4|t} - \\bar{\\pi_t}) + \\beta_{11}(i_t^{eq} + \\bar{\\pi}_t) + \\epsilon_t^{i} \\] The first step is to write down the system of equations according to the standard adopted by the package. A careful look at the equations blocks below should be enough to understand how they work.\n\nmodel_spec <- \"\nMODEL\n\nCOMMENT> IS Curve\nBEHAVIORAL> YGAP\nTSRANGE 2005 1 2022 4\nEQ> YGAP = b1*TSLAG(YGAP,1) + b2*TSLAG((MPR- CPI_EXP - IR_EQ),1) + b3*TOT_GAP\nCOEFF> b1 b2 b3\n\nCOMMENT> Phillips Curve\nBEHAVIORAL> CPI_CORE\nTSRANGE 2005 1 2022 4\nEQ> CPI_CORE = b4*TSLAG(CPI_CORE,1) + b5*CPI_EXP + b6*(TSDELTALOG(CI_USD)) + b7*TSLAG(YGAP,1)\nCOEFF> b4 b5 b6 b7\nRESTRICT> b4+b5+b6=1\n\nCOMMENT> Monetary Policy Rule\nBEHAVIORAL> MPR\nTSRANGE 2005 1 2022 4\nEQ> MPR = b8*TSLAG(MPR,1) + b9*TSLAG(MPR,2) + b10*(CPI_EXP - CPI_TARGET_ADJ) + b11*(IR_EQ + CPI_TARGET_ADJ)\nCOEFF> b8 b9 b10 b11\nRESTRICT> b8+b9+b10=1\n\nEND\n\"\n\nThe next step is to load the model specification and the data. The data must be supplied as a list of time series objects (ts).\n\nlibrary(tidyverse)\nlibrary(bimets)\nbr_economy_data <- readRDS('data/ch13_br_economy_data.rds') \nmacro_model     <- LOAD_MODEL(modelText = model_spec)\n\nAnalyzing behaviorals...\nAnalyzing identities...\nOptimizing...\nLoaded model \"model_spec\":\n    3 behaviorals\n    0 identities\n   11 coefficients\n...LOAD MODEL OK\n\nmodel_data_ts   <- br_economy_data %>% \n  pivot_longer(-date, names_to = 'var', values_to = 'value') %>% \n  plyr::dlply(\n    .variables = 'var', \n    .fun = function(x){\n      TIMESERIES(x$value, START = c(2004,1), FREQ = 4)\n    }\n  )\nmacro_model <- LOAD_MODEL_DATA(\n  macro_model, \n  model_data_ts\n  )\n\nLoad model data \"model_data_ts\" into model \"model_spec\"...\n...LOAD MODEL DATA OK\n\n\nAt this point we are ready to estimate the model coefficients. By default the equations are estimated using OLS, but it’s also possible to use Instrumental Variables (IV). I used quietly = TRUE to suppress the model output print because it’s lengthy. But I do recommend you to take a glance at it by setting this argument to FALSE or by removing it altogether.\n\nmodel_fit <- ESTIMATE(\n  macro_model, \n  estTech = 'OLS',\n  quietly = TRUE\n)\n\nFinally, we can use our estimated model to produce forecasts for future values. For this, we first need to provide future values for the exogenous variables. The TSEXTEND function makes this process very simple by providing several ways to extend the time series of the exogenous variables. In the example below, I made different assumptions to illustrate some of the possibilities.\nFor example, I assumed that both the CPI target and the equilibrium real interest rate will remain constant; the expectations for CPI will evolve according to a linear trend; the gap of terms of trade will decrease by 2.4% each quarter, which is the mean of the last four quarters; and the imported prices will decrease 2% each quarter, partially reverting the surge of the last years.\n\nmodel_fit$modelData <-  within(\n  model_fit$modelData, {\n    CPI_TARGET_ADJ = TSEXTEND(CPI_TARGET_ADJ, UPTO=c(2026,1),EXTMODE='CONSTANT')\n    CPI_EXP        = TSEXTEND(CPI_EXP,        UPTO=c(2026,1),EXTMODE='LINEAR')\n    CI_USD         = TSEXTEND(CI_USD,         UPTO=c(2026,1),EXTMODE='MYRATE', FACTOR = (1-0.02))\n    IR_EQ          = TSEXTEND(IR_EQ,          UPTO=c(2026,1),EXTMODE='CONSTANT')\n    TOT_GAP        = TSEXTEND(TOT_GAP,        UPTO=c(2026,1),EXTMODE='MYCONST', FACTOR = -2.4)\n  }\n)\n\nWe can convert this object into tidy format in order to make it easier to plot all the extended time series in a single panel.\n\n\nShow the code\ndo.call(ts.union, model_fit$modelData) %>%\n  timetk::tk_tbl() %>% \n  pivot_longer(-index, names_to = 'var', values_to = 'value') %>% \n  filter(!var %in% c('CPI_CORE', 'YGAP', 'MPR')) %>%\n  mutate(scenario = if_else(index >= '2023 Q1', 'Y', 'N')) %>% \n  ggplot(aes(x = index, y = value, color = scenario)) +\n  geom_line(lwd = 1) +\n  scale_color_manual(values = c('black', 'red')) +\n  facet_wrap(~ var, scales = 'free_y') +\n  theme(legend.position = 'top') +\n  zoo::scale_x_yearqtr(n = 5, format = '%Y') +\n  labs(\n    title = 'Scenarios for exogenous variables',\n    x = '',\n    y = ''\n  )\n\n\n\n\n\nIn the last step we call the SIMULATE function. Again, with a few lines of code we can transform the output into tidy format to produce a prettier plot.\n\nmodel_sim <- SIMULATE(\n  model_fit,\n  simType        = 'FORECAST',\n  TSRANGE        = c(2023,1,2025,1),\n  simConvergence = 0.00001,\n  simIterLimit   = 100,\n  quietly        = TRUE\n)\n\n\n\nShow the code\noutput <- do.call(ts.intersect, model_fit$modelData) %>% \n  timetk::tk_tbl(rename_index = 'date') %>% \n  mutate(type = 'Observed') %>% \n  bind_rows(\n    do.call(ts.intersect, model_sim$simulation[1:3]) %>% \n      timetk::tk_tbl(rename_index = 'date') %>% \n      mutate(type = 'Forecast')\n  ) %>% \n  mutate(date = zoo::as.yearqtr(date))\noutput %>% \n  select(date, YGAP, CPI_CORE, MPR, type) %>% \n  pivot_longer(-c(date, type), names_to = 'var', values_to = 'value') %>% \n  ggplot(aes(x = date)) +\n  geom_line(aes(y = value, color = type, linetype = type)) +\n  scale_linetype_manual(values = c(2,1)) +\n  zoo::scale_x_yearqtr(n = 10, format = '%YQ%q') +\n  facet_wrap(~ var, scales = 'free_y', nrow = 3) +\n  theme(legend.position = 'top') +\n  labs(\n    title = 'Forecasts for economic variables',\n    x = '',\n    y = '',\n    linetype = '',\n    color = ''\n    )"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Eli, Nir, Haberkorn Flora, and Cascaldi-Garcia Danilo. 2021.\n“International Measures of Common Inflation.”\n\n\nGrolemund, G., and H. Wickham. 2017. R for Data Science, 1st\nEdition. O’Reilly Media.\n\n\nHolmes, E. E., M. D. Scheuerell, and E. J. Ward. 2021. Analysis of\nMultivariate Time Series Using the MARSS Package, Version 3.11.4.\nNOAA Fisheries, Northwest Fisheries Science Center.\n\n\nHyndman, R. J., and G. Athanasopoulos. 2018. Forecasting: Principles\nand Practice, 2nd Edition. OTexts: Melbourne, Australia.\n\n\nWickham, H., Danielle Navarro, and Thomas Lin Pedersen. 2019.\nGgplot2: Elegant Graphics for Data Analysis, 3rd Edition.\nSpringer."
  }
]